https://github.com/PowerDNS/pdns/commit/e6a9dde524b5

--- arguments.cc.orig	2018-03-29 13:04:45 UTC
+++ arguments.cc
@@ -443,7 +443,7 @@ bool ArgvMap::file(const char *fname, bool lax, bool i
     set("include-dir","Directory to include configuration files from");
 
   if(!parseFile(fname, "", lax)) {
-    L << Logger::Warning << "Unable to open " << fname << std::endl;
+    g_log << Logger::Warning << "Unable to open " << fname << std::endl;
     return false;
   }
 
@@ -453,7 +453,7 @@ bool ArgvMap::file(const char *fname, bool lax, bool i
     gatherIncludes(extraConfigs); 
     for(const std::string& fn :  extraConfigs) {
       if (!file(fn.c_str(), lax, true)) {
-        L << Logger::Error << fn << " could not be parsed" << std::endl;
+        g_log << Logger::Error << fn << " could not be parsed" << std::endl;
         throw ArgException(fn + " could not be parsed");
       }
     }
@@ -471,18 +471,18 @@ void ArgvMap::gatherIncludes(std::vector<std::string> 
 
     // stat
     if (stat(params["include-dir"].c_str(), &st)) {
-       L << Logger::Error << params["include-dir"] << " does not exist!" << std::endl;
+       g_log << Logger::Error << params["include-dir"] << " does not exist!" << std::endl;
        throw ArgException(params["include-dir"] + " does not exist!");
     }
 
     // wonder if it's accessible directory
     if (!S_ISDIR(st.st_mode)) {
-       L << Logger::Error << params["include-dir"] << " is not a directory" << std::endl;
+       g_log << Logger::Error << params["include-dir"] << " is not a directory" << std::endl;
        throw ArgException(params["include-dir"] + " is not a directory");
     }
 
     if (!(dir = opendir(params["include-dir"].c_str()))) {
-       L << Logger::Error << params["include-dir"] << " is not accessible" << std::endl;
+       g_log << Logger::Error << params["include-dir"] << " is not accessible" << std::endl;
        throw ArgException(params["include-dir"] + " is not accessible");
     }
 
@@ -494,7 +494,7 @@ void ArgvMap::gatherIncludes(std::vector<std::string> 
         namebuf << params["include-dir"].c_str() << "/" << ent->d_name; // FIXME: Use some path separator
         // ensure it's readable file
         if (stat(namebuf.str().c_str(), &st) || !S_ISREG(st.st_mode)) {
-          L << Logger::Error << namebuf.str() << " is not a file" << std::endl;
+          g_log << Logger::Error << namebuf.str() << " is not a file" << std::endl;
           closedir(dir);
           throw ArgException(namebuf.str() + " does not exist!");
         }
--- dns.hh.orig	2018-03-29 13:04:45 UTC
+++ dns.hh
@@ -225,7 +225,6 @@ inline uint16_t * getFlagsFromDNSHeader(struct dnshead
 #define FLAGS_CD_OFFSET (12)
 #endif
 
-#define L theL()
 extern time_t s_starttime;
 
 uint32_t hashQuestion(const char* packet, uint16_t len, uint32_t init);
--- gss_context.cc.orig	2018-03-29 13:04:45 UTC
+++ gss_context.cc
@@ -456,17 +456,17 @@ bool gss_add_signature(const DNSName& context, const s
   string tmp_mac;
   GssContext gssctx(context);
   if (!gssctx.valid()) {
-    L<<Logger::Error<<"GSS context '"<<context<<"' is not valid"<<endl;
+    g_log<<Logger::Error<<"GSS context '"<<context<<"' is not valid"<<endl;
     for(const string& error :  gssctx.getErrorStrings()) {
-       L<<Logger::Error<<"GSS error: "<<error<<endl;;
+       g_log<<Logger::Error<<"GSS error: "<<error<<endl;;
     }
     return false;
   }
 
   if (!gssctx.sign(message, tmp_mac)) {
-    L<<Logger::Error<<"Could not sign message using GSS context '"<<context<<"'"<<endl;
+    g_log<<Logger::Error<<"Could not sign message using GSS context '"<<context<<"'"<<endl;
     for(const string& error :  gssctx.getErrorStrings()) {
-       L<<Logger::Error<<"GSS error: "<<error<<endl;;
+       g_log<<Logger::Error<<"GSS error: "<<error<<endl;;
     }
     return false;
   }
@@ -477,17 +477,17 @@ bool gss_add_signature(const DNSName& context, const s
 bool gss_verify_signature(const DNSName& context, const std::string& message, const std::string& mac) {
   GssContext gssctx(context);
   if (!gssctx.valid()) {
-    L<<Logger::Error<<"GSS context '"<<context<<"' is not valid"<<endl;
+    g_log<<Logger::Error<<"GSS context '"<<context<<"' is not valid"<<endl;
     for(const string& error :  gssctx.getErrorStrings()) {
-       L<<Logger::Error<<"GSS error: "<<error<<endl;;
+       g_log<<Logger::Error<<"GSS error: "<<error<<endl;;
     }
     return false;
   }
 
   if (!gssctx.verify(message, mac)) {
-    L<<Logger::Error<<"Could not verify message using GSS context '"<<context<<"'"<<endl;
+    g_log<<Logger::Error<<"Could not verify message using GSS context '"<<context<<"'"<<endl;
     for(const string& error :  gssctx.getErrorStrings()) {
-       L<<Logger::Error<<"GSS error: "<<error<<endl;;
+       g_log<<Logger::Error<<"GSS error: "<<error<<endl;;
     }
     return false;
   }
--- logger.cc.orig	2018-03-29 13:04:45 UTC
+++ logger.cc
@@ -32,15 +32,9 @@ extern StatBag S;
 #include "namespaces.hh"
 
 pthread_once_t Logger::s_once;
-pthread_key_t Logger::s_loggerKey;
+pthread_key_t Logger::g_loggerKey;
 
-Logger &theL(const string &pname)
-{
-  static Logger l("", LOG_DAEMON);
-  if(!pname.empty())
-    l.setName(pname);
-  return l;
-}
+Logger g_log("", LOG_DAEMON);
 
 void Logger::log(const string &msg, Urgency u)
 {
@@ -104,7 +98,7 @@ void Logger::setName(const string &_name)
 
 void Logger::initKey()
 {
-  if(pthread_key_create(&s_loggerKey, perThreadDestructor))
+  if(pthread_key_create(&g_loggerKey, perThreadDestructor))
     unixDie("Creating thread key for logger");
 }
 
@@ -139,13 +133,13 @@ void Logger::perThreadDestructor(void* buf)
 
 Logger::PerThread* Logger::getPerThread()
 {
-  void *buf=pthread_getspecific(s_loggerKey);
+  void *buf=pthread_getspecific(g_loggerKey);
   PerThread* ret;
   if(buf)
     ret = (PerThread*) buf;
   else {
     ret = new PerThread();
-    pthread_setspecific(s_loggerKey, (void*)ret);
+    pthread_setspecific(g_loggerKey, (void*)ret);
   }
   return ret;
 }
--- logger.hh.orig	2018-03-29 13:04:45 UTC
+++ logger.hh
@@ -70,9 +70,9 @@ class Logger (public)
   void resetFlags(){flags=0;open();} //!< zero the flags
   /** Use this to stream to your log, like this:
       \code
-      L<<"This is an informational message"<<endl; // logged at default loglevel (Info)
-      L<<Logger::Warning<<"Out of diskspace"<<endl; // Logged as a warning 
-      L<<"This is an informational message"<<endl; // logged AGAIN at default loglevel (Info)
+      g_log<<"This is an informational message"<<endl; // logged at default loglevel (Info)
+      g_log<<Logger::Warning<<"Out of diskspace"<<endl; // Logged as a warning 
+      g_log<<"This is an informational message"<<endl; // logged AGAIN at default loglevel (Info)
       \endcode
   */
   Logger& operator<<(const char *s);
@@ -113,10 +113,10 @@ class Logger (public)
   bool d_disableSyslog;
   bool d_timestamps{true};
   static pthread_once_t s_once;
-  static pthread_key_t s_loggerKey;
+  static pthread_key_t g_loggerKey;
 };
 
-extern Logger &theL(const string &pname="");
+extern Logger g_log;
 
 #ifdef VERBOSELOG
 #define DLOG(x) x
--- lua-recursor4.cc.orig	2018-03-29 13:04:45 UTC
+++ lua-recursor4.cc
@@ -286,7 +286,7 @@ RecursorLua4::RecursorLua4(const std::string& fname)
           cas.insert(boost::get<ComboAddress>(in));
         }
       }
-      catch(std::exception& e) { theL() <<Logger::Error<<e.what()<<endl; }
+      catch(std::exception& e) { g_log <<Logger::Error<<e.what()<<endl; }
     });
 
   d_lw->registerFunction<bool(cas_t::*)(const ComboAddress&)>("check",[](const cas_t& cas, const ComboAddress&ca) {
@@ -451,7 +451,7 @@ RecursorLua4::RecursorLua4(const std::string& fname)
         }
       }
       catch(std::exception& e) {
-        theL() <<Logger::Error<<e.what()<<endl;
+        g_log <<Logger::Error<<e.what()<<endl;
       }
     }
   );
@@ -461,7 +461,7 @@ RecursorLua4::RecursorLua4(const std::string& fname)
 
 
   d_lw->writeFunction("pdnslog", [](const std::string& msg, boost::optional<int> loglevel) {
-      theL() << (Logger::Urgency)loglevel.get_value_or(Logger::Warning) << msg<<endl;
+      g_log << (Logger::Urgency)loglevel.get_value_or(Logger::Warning) << msg<<endl;
     });
   typedef vector<pair<string, int> > in_t;
   vector<pair<string, boost::variant<int, in_t, struct timeval* > > >  pd{
@@ -719,7 +719,7 @@ loop:;
         dq.udpAnswer = GenUDPQueryResponse(dq.udpQueryDest, dq.udpQuery);
         auto cbFunc = d_lw->readVariable<boost::optional<luacall_t>>(dq.udpCallback).get_value_or(0);
         if(!cbFunc) {
-          theL()<<Logger::Error<<"Attempted callback for Lua UDP Query/Response which could not be found"<<endl;
+          g_log<<Logger::Error<<"Attempted callback for Lua UDP Query/Response which could not be found"<<endl;
           return false;
         }
         bool result=cbFunc(&dq);
--- lua-recursor4.hh.orig	2018-03-29 13:04:45 UTC
+++ lua-recursor4.hh
@@ -43,9 +43,7 @@ unsigned int getRecursorThreadId();
 class LuaContext;
 
 #if defined(HAVE_LUA)
-#undef L
 #include "ext/luawrapper/include/LuaContext.hpp"
-#define L theL()
 #endif
 
 // pdns_ffi_param_t is a lightuserdata
--- lwres.cc.orig	2018-03-29 13:04:45 UTC
+++ lwres.cc
@@ -236,7 +236,7 @@ int asyncresolve(const ComboAddress& ip, const DNSName
 
     if(domain != mdp.d_qname) { 
       if(!mdp.d_qname.empty() && domain.toString().find((char)0) == string::npos /* ugly */) {// embedded nulls are too noisy, plus empty domains are too
-        L<<Logger::Notice<<"Packet purporting to come from remote server "<<ip.toString()<<" contained wrong answer: '" << domain << "' != '" << mdp.d_qname << "'" << endl;
+        g_log<<Logger::Notice<<"Packet purporting to come from remote server "<<ip.toString()<<" contained wrong answer: '" << domain << "' != '" << mdp.d_qname << "'" << endl;
       }
       // unexpected count has already been done @ pdns_recursor.cc
       goto out;
@@ -276,7 +276,7 @@ int asyncresolve(const ComboAddress& ip, const DNSName
   }
   catch(std::exception &mde) {
     if(::arg().mustDo("log-common-errors"))
-      L<<Logger::Notice<<"Unable to parse packet from remote server "<<ip.toString()<<": "<<mde.what()<<endl;
+      g_log<<Logger::Notice<<"Unable to parse packet from remote server "<<ip.toString()<<": "<<mde.what()<<endl;
     lwr->d_rcode = RCode::FormErr;
     g_stats.serverParseError++;
 #ifdef HAVE_PROTOBUF
@@ -287,7 +287,7 @@ int asyncresolve(const ComboAddress& ip, const DNSName
     return 1; // success - oddly enough
   }
   catch(...) {
-    L<<Logger::Notice<<"Unknown error parsing packet from remote server"<<endl;
+    g_log<<Logger::Notice<<"Unknown error parsing packet from remote server"<<endl;
   }
   
   g_stats.serverParseError++; 
--- pdns_recursor.cc.orig	2018-03-29 13:04:45 UTC
+++ pdns_recursor.cc
@@ -367,12 +367,12 @@ static void setSocketBuffer(int fd, int optname, uint3
   socklen_t len=sizeof(psize);
 
   if(!getsockopt(fd, SOL_SOCKET, optname, (char*)&psize, &len) && psize > size) {
-    L<<Logger::Error<<"Not decreasing socket buffer size from "<<psize<<" to "<<size<<endl;
+    g_log<<Logger::Error<<"Not decreasing socket buffer size from "<<psize<<" to "<<size<<endl;
     return;
   }
 
   if (setsockopt(fd, SOL_SOCKET, optname, (char*)&size, sizeof(size)) < 0 )
-    L<<Logger::Error<<"Unable to raise socket buffer size to "<<size<<": "<<strerror(errno)<<endl;
+    g_log<<Logger::Error<<"Unable to raise socket buffer size to "<<size<<": "<<strerror(errno)<<endl;
 }
 
 
@@ -415,7 +415,7 @@ class UDPClientSocks (public)
         closesocket(*fd);
       }
       catch(const PDNSException& e) {
-        L<<Logger::Error<<"Error closing UDP socket after connect() failed: "<<e.reason<<endl;
+        g_log<<Logger::Error<<"Error closing UDP socket after connect() failed: "<<e.reason<<endl;
       }
 
       if(err==ENETUNREACH) // Seth "My Interfaces Are Like A Yo Yo" Arnold special
@@ -453,7 +453,7 @@ class UDPClientSocks (public)
       closesocket(*i);
     }
     catch(const PDNSException& e) {
-      L<<Logger::Error<<"Error closing returned UDP socket: "<<e.reason<<endl;
+      g_log<<Logger::Error<<"Error closing returned UDP socket: "<<e.reason<<endl;
     }
 
     d_socks.erase(i++);
@@ -569,7 +569,7 @@ int arecvfrom(char *data, size_t len, int flags, const
     *d_len=packet.size();
     memcpy(data,packet.c_str(),min(len,*d_len));
     if(*nearMissLimit && pident.nearMisses > *nearMissLimit) {
-      L<<Logger::Error<<"Too many ("<<pident.nearMisses<<" > "<<*nearMissLimit<<") bogus answers for '"<<domain<<"' from "<<fromaddr.toString()<<", assuming spoof attempt."<<endl;
+      g_log<<Logger::Error<<"Too many ("<<pident.nearMisses<<" > "<<*nearMissLimit<<") bogus answers for '"<<domain<<"' from "<<fromaddr.toString()<<", assuming spoof attempt."<<endl;
       g_stats.spoofCount++;
       return -1;
     }
@@ -589,7 +589,7 @@ static void writePid(void)
   if(of)
     of<< Utility::getpid() <<endl;
   else
-    L<<Logger::Error<<"Writing pid for "<<Utility::getpid()<<" to "<<s_pidfname<<" failed: "<<strerror(errno)<<endl;
+    g_log<<Logger::Error<<"Writing pid for "<<Utility::getpid()<<" to "<<s_pidfname<<" failed: "<<strerror(errno)<<endl;
 }
 
 TCPConnection::TCPConnection(int fd, const ComboAddress& addr) : d_remote(addr), d_fd(fd)
@@ -602,10 +602,10 @@ TCPConnection::~TCPConnection()
 {
   try {
     if(closesocket(d_fd) < 0)
-      L<<Logger::Error<<"Error closing socket for TCPConnection"<<endl;
+      g_log<<Logger::Error<<"Error closing socket for TCPConnection"<<endl;
   }
   catch(const PDNSException& e) {
-    L<<Logger::Error<<"Error closing TCPConnection socket: "<<e.reason<<endl;
+    g_log<<Logger::Error<<"Error closing TCPConnection socket: "<<e.reason<<endl;
   }
 
   if(t_tcpClientCounts->count(d_remote) && !(*t_tcpClientCounts)[d_remote]--)
@@ -858,12 +858,12 @@ static void startDoResolve(void *p)
 
 
     if(!g_quiet || tracedQuery) {
-      L<<Logger::Warning<<t_id<<" ["<<MT->getTid()<<"/"<<MT->numProcesses()<<"] " << (dc->d_tcp ? "TCP " : "") << "question for '"<<dc->d_mdp.d_qname<<"|"
+      g_log<<Logger::Warning<<t_id<<" ["<<MT->getTid()<<"/"<<MT->numProcesses()<<"] " << (dc->d_tcp ? "TCP " : "") << "question for '"<<dc->d_mdp.d_qname<<"|"
        <<DNSRecordContent::NumberToType(dc->d_mdp.d_qtype)<<"' from "<<dc->getRemote();
       if(!dc->d_ednssubnet.source.empty()) {
-        L<<" (ecs "<<dc->d_ednssubnet.source.toString()<<")";
+        g_log<<" (ecs "<<dc->d_ednssubnet.source.toString()<<")";
       }
-      L<<endl;
+      g_log<<endl;
     }
 
     sr.setId(MT->getTid());
@@ -926,7 +926,7 @@ static void startDoResolve(void *p)
       }
       catch(ImmediateServFailException &e) {
         if(g_logCommonErrors)
-          L<<Logger::Notice<<"Sending SERVFAIL to "<<dc->getRemote()<<" during resolve of '"<<dc->d_mdp.d_qname<<"' because: "<<e.reason<<endl;
+          g_log<<Logger::Notice<<"Sending SERVFAIL to "<<dc->getRemote()<<" during resolve of '"<<dc->d_mdp.d_qname<<"' because: "<<e.reason<<endl;
         res = RCode::ServFail;
       }
 
@@ -1048,7 +1048,7 @@ static void startDoResolve(void *p)
         boost::split(lines, trace, boost::is_any_of("\n"));
         for(const string& line : lines) {
           if(!line.empty())
-            L<<Logger::Warning<< line << endl;
+            g_log<<Logger::Warning<< line << endl;
         }
       }
     }
@@ -1065,14 +1065,14 @@ static void startDoResolve(void *p)
       if(!shouldNotValidate && sr.isDNSSECValidationRequested()) {
         try {
           if(sr.doLog()) {
-            L<<Logger::Warning<<"Starting validation of answer to "<<dc->d_mdp.d_qname<<"|"<<QType(dc->d_mdp.d_qtype).getName()<<" for "<<dc->d_remote.toStringWithPort()<<endl;
+            g_log<<Logger::Warning<<"Starting validation of answer to "<<dc->d_mdp.d_qname<<"|"<<QType(dc->d_mdp.d_qtype).getName()<<" for "<<dc->d_remote.toStringWithPort()<<endl;
           }
 
           auto state = sr.getValidationState();
 
           if(state == Secure) {
             if(sr.doLog()) {
-              L<<Logger::Warning<<"Answer to "<<dc->d_mdp.d_qname<<"|"<<QType(dc->d_mdp.d_qtype).getName()<<" for "<<dc->d_remote.toStringWithPort()<<" validates correctly"<<endl;
+              g_log<<Logger::Warning<<"Answer to "<<dc->d_mdp.d_qname<<"|"<<QType(dc->d_mdp.d_qtype).getName()<<" for "<<dc->d_remote.toStringWithPort()<<" validates correctly"<<endl;
             }
             
             // Is the query source interested in the value of the ad-bit?
@@ -1081,34 +1081,34 @@ static void startDoResolve(void *p)
           }
           else if(state == Insecure) {
             if(sr.doLog()) {
-              L<<Logger::Warning<<"Answer to "<<dc->d_mdp.d_qname<<"|"<<QType(dc->d_mdp.d_qtype).getName()<<" for "<<dc->d_remote.toStringWithPort()<<" validates as Insecure"<<endl;
+              g_log<<Logger::Warning<<"Answer to "<<dc->d_mdp.d_qname<<"|"<<QType(dc->d_mdp.d_qtype).getName()<<" for "<<dc->d_remote.toStringWithPort()<<" validates as Insecure"<<endl;
             }
             
             pw.getHeader()->ad=0;
           }
           else if(state == Bogus) {
             if(g_dnssecLogBogus || sr.doLog() || g_dnssecmode == DNSSECMode::ValidateForLog) {
-              L<<Logger::Warning<<"Answer to "<<dc->d_mdp.d_qname<<"|"<<QType(dc->d_mdp.d_qtype).getName()<<" for "<<dc->d_remote.toStringWithPort()<<" validates as Bogus"<<endl;
+              g_log<<Logger::Warning<<"Answer to "<<dc->d_mdp.d_qname<<"|"<<QType(dc->d_mdp.d_qtype).getName()<<" for "<<dc->d_remote.toStringWithPort()<<" validates as Bogus"<<endl;
             }
             
             // Does the query or validation mode sending out a SERVFAIL on validation errors?
             if(!pw.getHeader()->cd && (g_dnssecmode == DNSSECMode::ValidateAll || dc->d_mdp.d_header.ad || DNSSECOK)) {
               if(sr.doLog()) {
-                L<<Logger::Warning<<"Sending out SERVFAIL for "<<dc->d_mdp.d_qname<<"|"<<QType(dc->d_mdp.d_qtype).getName()<<" because recursor or query demands it for Bogus results"<<endl;
+                g_log<<Logger::Warning<<"Sending out SERVFAIL for "<<dc->d_mdp.d_qname<<"|"<<QType(dc->d_mdp.d_qtype).getName()<<" because recursor or query demands it for Bogus results"<<endl;
               }
               
               pw.getHeader()->rcode=RCode::ServFail;
               goto sendit;
             } else {
               if(sr.doLog()) {
-                L<<Logger::Warning<<"Not sending out SERVFAIL for "<<dc->d_mdp.d_qname<<"|"<<QType(dc->d_mdp.d_qtype).getName()<<" Bogus validation since neither config nor query demands this"<<endl;
+                g_log<<Logger::Warning<<"Not sending out SERVFAIL for "<<dc->d_mdp.d_qname<<"|"<<QType(dc->d_mdp.d_qtype).getName()<<" Bogus validation since neither config nor query demands this"<<endl;
               }
             }
           }
         }
         catch(ImmediateServFailException &e) {
           if(g_logCommonErrors)
-            L<<Logger::Notice<<"Sending SERVFAIL to "<<dc->getRemote()<<" during validation of '"<<dc->d_mdp.d_qname<<"|"<<QType(dc->d_mdp.d_qtype).getName()<<"' because: "<<e.reason<<endl;
+            g_log<<Logger::Notice<<"Sending SERVFAIL to "<<dc->getRemote()<<" during validation of '"<<dc->d_mdp.d_qname<<"|"<<QType(dc->d_mdp.d_qtype).getName()<<"' because: "<<e.reason<<endl;
           pw.getHeader()->rcode=RCode::ServFail;
           goto sendit;
         }
@@ -1195,7 +1195,7 @@ static void startDoResolve(void *p)
 	addCMsgSrcAddr(&msgh, cbuf, &dc->d_local, 0);
       }
       if(sendmsg(dc->d_socket, &msgh, 0) < 0 && g_logCommonErrors) 
-        L<<Logger::Warning<<"Sending UDP reply to client "<<dc->d_remote.toStringWithPort()<<" failed with: "<<strerror(errno)<<endl;
+        g_log<<Logger::Warning<<"Sending UDP reply to client "<<dc->d_remote.toStringWithPort()<<" failed with: "<<strerror(errno)<<endl;
 
       if(!SyncRes::s_nopacketcache && !variableAnswer && !sr.wasVariable() ) {
         t_packetCache->insertResponsePacket(dc->d_tag, dc->d_qhash, dc->d_mdp.d_qname, dc->d_mdp.d_qtype, dc->d_mdp.d_qclass,
@@ -1221,11 +1221,11 @@ static void startDoResolve(void *p)
       bool hadError=true;
 
       if(wret == 0)
-        L<<Logger::Error<<"EOF writing TCP answer to "<<dc->getRemote()<<endl;
+        g_log<<Logger::Error<<"EOF writing TCP answer to "<<dc->getRemote()<<endl;
       else if(wret < 0 )
-        L<<Logger::Error<<"Error writing TCP answer to "<<dc->getRemote()<<": "<< strerror(errno) <<endl;
+        g_log<<Logger::Error<<"Error writing TCP answer to "<<dc->getRemote()<<": "<< strerror(errno) <<endl;
       else if((unsigned int)wret != 2 + packet.size())
-        L<<Logger::Error<<"Oops, partial answer sent to "<<dc->getRemote()<<" for "<<dc->d_mdp.d_qname<<" (size="<< (2 + packet.size()) <<", sent "<<wret<<")"<<endl;
+        g_log<<Logger::Error<<"Oops, partial answer sent to "<<dc->getRemote()<<" for "<<dc->d_mdp.d_qname<<" (size="<< (2 + packet.size()) <<", sent "<<wret<<")"<<endl;
       else
         hadError=false;
 
@@ -1250,16 +1250,16 @@ static void startDoResolve(void *p)
     }
     float spent=makeFloat(sr.getNow()-dc->d_now);
     if(!g_quiet) {
-      L<<Logger::Error<<t_id<<" ["<<MT->getTid()<<"/"<<MT->numProcesses()<<"] answer to "<<(dc->d_mdp.d_header.rd?"":"non-rd ")<<"question '"<<dc->d_mdp.d_qname<<"|"<<DNSRecordContent::NumberToType(dc->d_mdp.d_qtype);
-      L<<"': "<<ntohs(pw.getHeader()->ancount)<<" answers, "<<ntohs(pw.getHeader()->arcount)<<" additional, took "<<sr.d_outqueries<<" packets, "<<
+      g_log<<Logger::Error<<t_id<<" ["<<MT->getTid()<<"/"<<MT->numProcesses()<<"] answer to "<<(dc->d_mdp.d_header.rd?"":"non-rd ")<<"question '"<<dc->d_mdp.d_qname<<"|"<<DNSRecordContent::NumberToType(dc->d_mdp.d_qtype);
+      g_log<<"': "<<ntohs(pw.getHeader()->ancount)<<" answers, "<<ntohs(pw.getHeader()->arcount)<<" additional, took "<<sr.d_outqueries<<" packets, "<<
 	sr.d_totUsec/1000.0<<" netw ms, "<< spent*1000.0<<" tot ms, "<<
 	sr.d_throttledqueries<<" throttled, "<<sr.d_timeouts<<" timeouts, "<<sr.d_tcpoutqueries<<" tcp connections, rcode="<< res;
 
       if(!shouldNotValidate && sr.isDNSSECValidationRequested()) {
-	L<< ", dnssec="<<vStates[sr.getValidationState()];
+	g_log<< ", dnssec="<<vStates[sr.getValidationState()];
       }
 	
-      L<<endl;
+      g_log<<endl;
 
     }
 
@@ -1307,28 +1307,28 @@ static void startDoResolve(void *p)
     dc=0;
   }
   catch(PDNSException &ae) {
-    L<<Logger::Error<<"startDoResolve problem "<<makeLoginfo(dc)<<": "<<ae.reason<<endl;
+    g_log<<Logger::Error<<"startDoResolve problem "<<makeLoginfo(dc)<<": "<<ae.reason<<endl;
     delete dc;
   }
   catch(MOADNSException& e) {
-    L<<Logger::Error<<"DNS parser error "<<makeLoginfo(dc) <<": "<<dc->d_mdp.d_qname<<", "<<e.what()<<endl;
+    g_log<<Logger::Error<<"DNS parser error "<<makeLoginfo(dc) <<": "<<dc->d_mdp.d_qname<<", "<<e.what()<<endl;
     delete dc;
   }
   catch(std::exception& e) {
-    L<<Logger::Error<<"STL error "<< makeLoginfo(dc)<<": "<<e.what();
+    g_log<<Logger::Error<<"STL error "<< makeLoginfo(dc)<<": "<<e.what();
 
     // Luawrapper nests the exception from Lua, so we unnest it here
     try {
         std::rethrow_if_nested(e);
     } catch(const std::exception& ne) {
-        L<<". Extra info: "<<ne.what();
+        g_log<<". Extra info: "<<ne.what();
     } catch(...) {}
 
-    L<<endl;
+    g_log<<endl;
     delete dc;
   }
   catch(...) {
-    L<<Logger::Error<<"Any other exception in a resolver context "<< makeLoginfo(dc) <<endl;
+    g_log<<Logger::Error<<"Any other exception in a resolver context "<< makeLoginfo(dc) <<endl;
   }
 
   g_stats.maxMThreadStackUsage = max(MT->getMaxStackUsage(), g_stats.maxMThreadStackUsage);
@@ -1436,7 +1436,7 @@ static void handleRunningTCPQuestion(int fd, FDMultipl
     }
     if(!bytes || bytes < 0) {
       if(g_logCommonErrors)
-        L<<Logger::Error<<"TCP client "<< conn->d_remote.toString() <<" disconnected after first byte"<<endl;
+        g_log<<Logger::Error<<"TCP client "<< conn->d_remote.toString() <<" disconnected after first byte"<<endl;
       t_fdm->removeReadFD(fd);
       return;
     }
@@ -1444,7 +1444,7 @@ static void handleRunningTCPQuestion(int fd, FDMultipl
   else if(conn->state==TCPConnection::GETQUESTION) {
     ssize_t bytes=recv(conn->getFD(), conn->data + conn->bytesread, conn->qlen - conn->bytesread, 0);
     if(!bytes || bytes < 0 || bytes > std::numeric_limits<std::uint16_t>::max()) {
-      L<<Logger::Error<<"TCP client "<< conn->d_remote.toString() <<" disconnected while reading question body"<<endl;
+      g_log<<Logger::Error<<"TCP client "<< conn->d_remote.toString() <<" disconnected while reading question body"<<endl;
       t_fdm->removeReadFD(fd);
       return;
     }
@@ -1459,7 +1459,7 @@ static void handleRunningTCPQuestion(int fd, FDMultipl
       catch(MOADNSException &mde) {
         g_stats.clientParseError++;
         if(g_logCommonErrors)
-          L<<Logger::Error<<"Unable to parse packet from TCP client "<< conn->d_remote.toString() <<endl;
+          g_log<<Logger::Error<<"Unable to parse packet from TCP client "<< conn->d_remote.toString() <<endl;
         return;
       }
       dc->d_tcpConnection = conn; // carry the torch
@@ -1503,14 +1503,14 @@ static void handleRunningTCPQuestion(int fd, FDMultipl
             }
             catch(const std::exception& e)  {
               if(g_logCommonErrors)
-                L<<Logger::Warning<<"Error parsing a query packet qname='"<<qname<<"' for tag determination, setting tag=0: "<<e.what()<<endl;
+                g_log<<Logger::Warning<<"Error parsing a query packet qname='"<<qname<<"' for tag determination, setting tag=0: "<<e.what()<<endl;
             }
           }
         }
         catch(const std::exception& e)
         {
           if(g_logCommonErrors)
-            L<<Logger::Warning<<"Error parsing a query packet for tag determination, setting tag=0: "<<e.what()<<endl;
+            g_log<<Logger::Warning<<"Error parsing a query packet for tag determination, setting tag=0: "<<e.what()<<endl;
         }
       }
 #ifdef HAVE_PROTOBUF
@@ -1530,20 +1530,20 @@ static void handleRunningTCPQuestion(int fd, FDMultipl
         }
         catch(std::exception& e) {
           if(g_logCommonErrors)
-            L<<Logger::Warning<<"Error parsing a TCP query packet for edns subnet: "<<e.what()<<endl;
+            g_log<<Logger::Warning<<"Error parsing a TCP query packet for edns subnet: "<<e.what()<<endl;
         }
       }
 #endif
       if(dc->d_mdp.d_header.qr) {
         delete dc;
         g_stats.ignoredCount++;
-        L<<Logger::Error<<"Ignoring answer from TCP client "<< conn->d_remote.toString() <<" on server socket!"<<endl;
+        g_log<<Logger::Error<<"Ignoring answer from TCP client "<< conn->d_remote.toString() <<" on server socket!"<<endl;
         return;
       }
       if(dc->d_mdp.d_header.opcode) {
         delete dc;
         g_stats.ignoredCount++;
-        L<<Logger::Error<<"Ignoring non-query opcode from TCP client "<< conn->d_remote.toString() <<" on server socket!"<<endl;
+        g_log<<Logger::Error<<"Ignoring non-query opcode from TCP client "<< conn->d_remote.toString() <<" on server socket!"<<endl;
         return;
       }
       else {
@@ -1569,7 +1569,7 @@ static void handleNewTCPQuestion(int fd, FDMultiplexer
         closesocket(newsock);
       }
       catch(const PDNSException& e) {
-        L<<Logger::Error<<"Error closing TCP socket after an over capacity drop: "<<e.reason<<endl;
+        g_log<<Logger::Error<<"Error closing TCP socket after an over capacity drop: "<<e.reason<<endl;
       }
       return;
     }
@@ -1578,14 +1578,14 @@ static void handleNewTCPQuestion(int fd, FDMultiplexer
       t_remotes->push_back(addr);
     if(t_allowFrom && !t_allowFrom->match(&addr)) {
       if(!g_quiet)
-        L<<Logger::Error<<"["<<MT->getTid()<<"] dropping TCP query from "<<addr.toString()<<", address not matched by allow-from"<<endl;
+        g_log<<Logger::Error<<"["<<MT->getTid()<<"] dropping TCP query from "<<addr.toString()<<", address not matched by allow-from"<<endl;
 
       g_stats.unauthorizedTCP++;
       try {
         closesocket(newsock);
       }
       catch(const PDNSException& e) {
-        L<<Logger::Error<<"Error closing TCP socket after an ACL drop: "<<e.reason<<endl;
+        g_log<<Logger::Error<<"Error closing TCP socket after an ACL drop: "<<e.reason<<endl;
       }
       return;
     }
@@ -1595,7 +1595,7 @@ static void handleNewTCPQuestion(int fd, FDMultiplexer
         closesocket(newsock); // don't call TCPConnection::closeAndCleanup here - did not enter it in the counts yet!
       }
       catch(const PDNSException& e) {
-        L<<Logger::Error<<"Error closing TCP socket after an overflow drop: "<<e.reason<<endl;
+        g_log<<Logger::Error<<"Error closing TCP socket after an overflow drop: "<<e.reason<<endl;
       }
       return;
     }
@@ -1687,14 +1687,14 @@ static string* doProcessUDPQuestion(const std::string&
           }
           catch(const std::exception& e)  {
             if(g_logCommonErrors)
-              L<<Logger::Warning<<"Error parsing a query packet qname='"<<qname<<"' for tag determination, setting tag=0: "<<e.what()<<endl;
+              g_log<<Logger::Warning<<"Error parsing a query packet qname='"<<qname<<"' for tag determination, setting tag=0: "<<e.what()<<endl;
           }
         }
       }
       catch(const std::exception& e)
       {
         if(g_logCommonErrors)
-          L<<Logger::Warning<<"Error parsing a query packet for tag determination, setting tag=0: "<<e.what()<<endl;
+          g_log<<Logger::Warning<<"Error parsing a query packet for tag determination, setting tag=0: "<<e.what()<<endl;
       }
     }
 
@@ -1732,7 +1732,7 @@ static string* doProcessUDPQuestion(const std::string&
       }
 #endif /* HAVE_PROTOBUF */
       if(!g_quiet)
-        L<<Logger::Notice<<t_id<< " question answered from packet cache tag="<<ctag<<" from "<<fromaddr.toString()<<endl;
+        g_log<<Logger::Notice<<t_id<< " question answered from packet cache tag="<<ctag<<" from "<<fromaddr.toString()<<endl;
 
       g_stats.packetCacheHits++;
       SyncRes::s_queries++;
@@ -1747,7 +1747,7 @@ static string* doProcessUDPQuestion(const std::string&
 	addCMsgSrcAddr(&msgh, cbuf, &destaddr, 0);
       }
       if(sendmsg(fd, &msgh, 0) < 0 && g_logCommonErrors)
-        L<<Logger::Warning<<"Sending UDP reply to client "<<fromaddr.toStringWithPort()<<" failed with: "<<strerror(errno)<<endl;
+        g_log<<Logger::Warning<<"Sending UDP reply to client "<<fromaddr.toStringWithPort()<<" failed with: "<<strerror(errno)<<endl;
 
       if(response.length() >= sizeof(struct dnsheader)) {
         struct dnsheader tmpdh;
@@ -1760,14 +1760,14 @@ static string* doProcessUDPQuestion(const std::string&
     }
   }
   catch(std::exception& e) {
-    L<<Logger::Error<<"Error processing or aging answer packet: "<<e.what()<<endl;
+    g_log<<Logger::Error<<"Error processing or aging answer packet: "<<e.what()<<endl;
     return 0;
   }
 
   if(t_pdl) {
     if(t_pdl->ipfilter(fromaddr, destaddr, *dh)) {
       if(!g_quiet)
-	L<<Logger::Notice<<t_id<<" ["<<MT->getTid()<<"/"<<MT->numProcesses()<<"] DROPPED question from "<<fromaddr.toStringWithPort()<<" based on policy"<<endl;
+	g_log<<Logger::Notice<<t_id<<" ["<<MT->getTid()<<"/"<<MT->numProcesses()<<"] DROPPED question from "<<fromaddr.toStringWithPort()<<" based on policy"<<endl;
       g_stats.policyDrops++;
       return 0;
     }
@@ -1775,7 +1775,7 @@ static string* doProcessUDPQuestion(const std::string&
 
   if(MT->numProcesses() > g_maxMThreads) {
     if(!g_quiet)
-      L<<Logger::Notice<<t_id<<" ["<<MT->getTid()<<"/"<<MT->numProcesses()<<"] DROPPED question from "<<fromaddr.toStringWithPort()<<", over capacity"<<endl;
+      g_log<<Logger::Notice<<t_id<<" ["<<MT->getTid()<<"/"<<MT->numProcesses()<<"] DROPPED question from "<<fromaddr.toStringWithPort()<<", over capacity"<<endl;
 
     g_stats.overCapacityDrops++;
     return 0;
@@ -1832,7 +1832,7 @@ static void handleNewUDPQuestion(int fd, FDMultiplexer
 
     if(t_allowFrom && !t_allowFrom->match(&fromaddr)) {
       if(!g_quiet)
-        L<<Logger::Error<<"["<<MT->getTid()<<"] dropping UDP query from "<<fromaddr.toString()<<", address not matched by allow-from"<<endl;
+        g_log<<Logger::Error<<"["<<MT->getTid()<<"] dropping UDP query from "<<fromaddr.toString()<<", address not matched by allow-from"<<endl;
 
       g_stats.unauthorizedUDP++;
       return;
@@ -1840,7 +1840,7 @@ static void handleNewUDPQuestion(int fd, FDMultiplexer
     BOOST_STATIC_ASSERT(offsetof(sockaddr_in, sin_port) == offsetof(sockaddr_in6, sin6_port));
     if(!fromaddr.sin4.sin_port) { // also works for IPv6
      if(!g_quiet)
-        L<<Logger::Error<<"["<<MT->getTid()<<"] dropping UDP query from "<<fromaddr.toStringWithPort()<<", can't deal with port 0"<<endl;
+        g_log<<Logger::Error<<"["<<MT->getTid()<<"] dropping UDP query from "<<fromaddr.toStringWithPort()<<", can't deal with port 0"<<endl;
 
       g_stats.clientParseError++; // not quite the best place to put it, but needs to go somewhere
       return;
@@ -1851,12 +1851,12 @@ static void handleNewUDPQuestion(int fd, FDMultiplexer
       if(dh->qr) {
         g_stats.ignoredCount++;
         if(g_logCommonErrors)
-          L<<Logger::Error<<"Ignoring answer from "<<fromaddr.toString()<<" on server socket!"<<endl;
+          g_log<<Logger::Error<<"Ignoring answer from "<<fromaddr.toString()<<" on server socket!"<<endl;
       }
       else if(dh->opcode) {
         g_stats.ignoredCount++;
         if(g_logCommonErrors)
-          L<<Logger::Error<<"Ignoring non-query opcode "<<dh->opcode<<" from "<<fromaddr.toString()<<" on server socket!"<<endl;
+          g_log<<Logger::Error<<"Ignoring non-query opcode "<<dh->opcode<<" from "<<fromaddr.toString()<<" on server socket!"<<endl;
       }
       else {
         string question(data, (size_t)len);
@@ -1889,12 +1889,12 @@ static void handleNewUDPQuestion(int fd, FDMultiplexer
     catch(MOADNSException& mde) {
       g_stats.clientParseError++;
       if(g_logCommonErrors)
-        L<<Logger::Error<<"Unable to parse packet from remote UDP client "<<fromaddr.toString() <<": "<<mde.what()<<endl;
+        g_log<<Logger::Error<<"Unable to parse packet from remote UDP client "<<fromaddr.toString() <<": "<<mde.what()<<endl;
     }
     catch(std::runtime_error& e) {
       g_stats.clientParseError++;
       if(g_logCommonErrors)
-        L<<Logger::Error<<"Unable to parse packet from remote UDP client "<<fromaddr.toString() <<": "<<e.what()<<endl;
+        g_log<<Logger::Error<<"Unable to parse packet from remote UDP client "<<fromaddr.toString() <<": "<<e.what()<<endl;
     }
   }
   else {
@@ -1938,17 +1938,17 @@ static void makeTCPServerSockets(unsigned int threadId
 
     int tmp=1;
     if(setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &tmp, sizeof tmp)<0) {
-      L<<Logger::Error<<"Setsockopt failed for TCP listening socket"<<endl;
+      g_log<<Logger::Error<<"Setsockopt failed for TCP listening socket"<<endl;
       exit(1);
     }
     if(sin.sin6.sin6_family == AF_INET6 && setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, &tmp, sizeof(tmp)) < 0) {
-      L<<Logger::Error<<"Failed to set IPv6 socket to IPv6 only, continuing anyhow: "<<strerror(errno)<<endl;
+      g_log<<Logger::Error<<"Failed to set IPv6 socket to IPv6 only, continuing anyhow: "<<strerror(errno)<<endl;
     }
 
 #ifdef TCP_DEFER_ACCEPT
     if(setsockopt(fd, SOL_TCP, TCP_DEFER_ACCEPT, &tmp, sizeof tmp) >= 0) {
       if(i==locals.begin())
-        L<<Logger::Error<<"Enabled TCP data-ready filter for (slight) DoS protection"<<endl;
+        g_log<<Logger::Error<<"Enabled TCP data-ready filter for (slight) DoS protection"<<endl;
     }
 #endif
 
@@ -1966,10 +1966,10 @@ static void makeTCPServerSockets(unsigned int threadId
 #ifdef TCP_FASTOPEN
       int fastOpenQueueSize = ::arg().asNum("tcp-fast-open");
       if (setsockopt(fd, IPPROTO_TCP, TCP_FASTOPEN, &fastOpenQueueSize, sizeof fastOpenQueueSize) < 0) {
-        L<<Logger::Error<<"Failed to enable TCP Fast Open for listening socket: "<<strerror(errno)<<endl;
+        g_log<<Logger::Error<<"Failed to enable TCP Fast Open for listening socket: "<<strerror(errno)<<endl;
       }
 #else
-      L<<Logger::Warning<<"TCP Fast Open configured but not supported for listening socket"<<endl;
+      g_log<<Logger::Warning<<"TCP Fast Open configured but not supported for listening socket"<<endl;
 #endif
     }
 
@@ -1986,9 +1986,9 @@ static void makeTCPServerSockets(unsigned int threadId
     // we don't need to update g_listenSocketsAddresses since it doesn't work for TCP/IP:
     //  - fd is not that which we know here, but returned from accept()
     if(sin.sin4.sin_family == AF_INET)
-      L<<Logger::Error<<"Listening for TCP queries on "<< sin.toString() <<":"<<st.port<<endl;
+      g_log<<Logger::Error<<"Listening for TCP queries on "<< sin.toString() <<":"<<st.port<<endl;
     else
-      L<<Logger::Error<<"Listening for TCP queries on ["<< sin.toString() <<"]:"<<st.port<<endl;
+      g_log<<Logger::Error<<"Listening for TCP queries on ["<< sin.toString() <<"]:"<<st.port<<endl;
   }
 }
 
@@ -2021,7 +2021,7 @@ static void makeUDPServerSockets(unsigned int threadId
       throw PDNSException("Making a UDP server socket for resolver: "+netstringerror());
     }
     if (!setSocketTimestamps(fd))
-      L<<Logger::Warning<<"Unable to enable timestamp reporting for socket"<<endl;
+      g_log<<Logger::Warning<<"Unable to enable timestamp reporting for socket"<<endl;
 
     if(IsAnyAddress(sin)) {
       if(sin.sin4.sin_family == AF_INET)
@@ -2033,7 +2033,7 @@ static void makeUDPServerSockets(unsigned int threadId
           g_fromtosockets.insert(fd);
 #endif
       if(sin.sin6.sin6_family == AF_INET6 && setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, &one, sizeof(one)) < 0) {
-	L<<Logger::Error<<"Failed to set IPv6 socket to IPv6 only, continuing anyhow: "<<strerror(errno)<<endl;
+	g_log<<Logger::Error<<"Failed to set IPv6 socket to IPv6 only, continuing anyhow: "<<strerror(errno)<<endl;
       }
     }
     if( ::arg().mustDo("non-local-bind") )
@@ -2060,9 +2060,9 @@ static void makeUDPServerSockets(unsigned int threadId
     deferredAdds[threadId].push_back(make_pair(fd, handleNewUDPQuestion));
     g_listenSocketsAddresses[fd]=sin;  // this is written to only from the startup thread, not from the workers
     if(sin.sin4.sin_family == AF_INET)
-      L<<Logger::Error<<"Listening for UDP queries on "<< sin.toString() <<":"<<st.port<<endl;
+      g_log<<Logger::Error<<"Listening for UDP queries on "<< sin.toString() <<":"<<st.port<<endl;
     else
-      L<<Logger::Error<<"Listening for UDP queries on ["<< sin.toString() <<"]:"<<st.port<<endl;
+      g_log<<Logger::Error<<"Listening for UDP queries on ["<< sin.toString() <<"]:"<<st.port<<endl;
   }
 }
 
@@ -2075,7 +2075,7 @@ static void daemonize(void)
 
   int i=open("/dev/null",O_RDWR); /* open stdin */
   if(i < 0)
-    L<<Logger::Critical<<"Unable to open /dev/null: "<<stringerror()<<endl;
+    g_log<<Logger::Critical<<"Unable to open /dev/null: "<<stringerror()<<endl;
   else {
     dup2(i,0); /* stdin */
     dup2(i,1); /* stderr */
@@ -2105,35 +2105,35 @@ static void doStats(void)
   uint64_t cacheMisses = broadcastAccFunction<uint64_t>(pleaseGetCacheMisses);
 
   if(g_stats.qcounter && (cacheHits + cacheMisses) && SyncRes::s_queries && SyncRes::s_outqueries) {
-    L<<Logger::Notice<<"stats: "<<g_stats.qcounter<<" questions, "<<
+    g_log<<Logger::Notice<<"stats: "<<g_stats.qcounter<<" questions, "<<
       broadcastAccFunction<uint64_t>(pleaseGetCacheSize)<< " cache entries, "<<
       broadcastAccFunction<uint64_t>(pleaseGetNegCacheSize)<<" negative entries, "<<
       (int)((cacheHits*100.0)/(cacheHits+cacheMisses))<<"% cache hits"<<endl;
 
-    L<<Logger::Notice<<"stats: throttle map: "
+    g_log<<Logger::Notice<<"stats: throttle map: "
       << broadcastAccFunction<uint64_t>(pleaseGetThrottleSize) <<", ns speeds: "
       << broadcastAccFunction<uint64_t>(pleaseGetNsSpeedsSize)<<endl;
-    L<<Logger::Notice<<"stats: outpacket/query ratio "<<(int)(SyncRes::s_outqueries*100.0/SyncRes::s_queries)<<"%";
-    L<<Logger::Notice<<", "<<(int)(SyncRes::s_throttledqueries*100.0/(SyncRes::s_outqueries+SyncRes::s_throttledqueries))<<"% throttled, "
+    g_log<<Logger::Notice<<"stats: outpacket/query ratio "<<(int)(SyncRes::s_outqueries*100.0/SyncRes::s_queries)<<"%";
+    g_log<<Logger::Notice<<", "<<(int)(SyncRes::s_throttledqueries*100.0/(SyncRes::s_outqueries+SyncRes::s_throttledqueries))<<"% throttled, "
      <<SyncRes::s_nodelegated<<" no-delegation drops"<<endl;
-    L<<Logger::Notice<<"stats: "<<SyncRes::s_tcpoutqueries<<" outgoing tcp connections, "<<
+    g_log<<Logger::Notice<<"stats: "<<SyncRes::s_tcpoutqueries<<" outgoing tcp connections, "<<
       broadcastAccFunction<uint64_t>(pleaseGetConcurrentQueries)<<" queries running, "<<SyncRes::s_outgoingtimeouts<<" outgoing timeouts"<<endl;
 
-    //L<<Logger::Notice<<"stats: "<<g_stats.ednsPingMatches<<" ping matches, "<<g_stats.ednsPingMismatches<<" mismatches, "<<
+    //g_log<<Logger::Notice<<"stats: "<<g_stats.ednsPingMatches<<" ping matches, "<<g_stats.ednsPingMismatches<<" mismatches, "<<
       //g_stats.noPingOutQueries<<" outqueries w/o ping, "<< g_stats.noEdnsOutQueries<<" w/o EDNS"<<endl;
 
-    L<<Logger::Notice<<"stats: " <<  broadcastAccFunction<uint64_t>(pleaseGetPacketCacheSize) <<
+    g_log<<Logger::Notice<<"stats: " <<  broadcastAccFunction<uint64_t>(pleaseGetPacketCacheSize) <<
     " packet cache entries, "<<(int)(100.0*broadcastAccFunction<uint64_t>(pleaseGetPacketCacheHits)/SyncRes::s_queries) << "% packet cache hits"<<endl;
 
     time_t now = time(0);
     if(lastOutputTime && lastQueryCount && now != lastOutputTime) {
-      L<<Logger::Notice<<"stats: "<< (SyncRes::s_queries - lastQueryCount) / (now - lastOutputTime) <<" qps (average over "<< (now - lastOutputTime) << " seconds)"<<endl;
+      g_log<<Logger::Notice<<"stats: "<< (SyncRes::s_queries - lastQueryCount) / (now - lastOutputTime) <<" qps (average over "<< (now - lastOutputTime) << " seconds)"<<endl;
     }
     lastOutputTime = now;
     lastQueryCount = SyncRes::s_queries;
   }
   else if(statsWanted)
-    L<<Logger::Notice<<"stats: no stats yet!"<<endl;
+    g_log<<Logger::Notice<<"stats: no stats yet!"<<endl;
 
   statsWanted=false;
 }
@@ -2184,19 +2184,19 @@ static void houseKeeping(void *)
 	}
 	catch(std::exception& e)
         {
-          L<<Logger::Error<<"Exception while performing security poll: "<<e.what()<<endl;
+          g_log<<Logger::Error<<"Exception while performing security poll: "<<e.what()<<endl;
         }
         catch(PDNSException& e)
         {
-          L<<Logger::Error<<"Exception while performing security poll: "<<e.reason<<endl;
+          g_log<<Logger::Error<<"Exception while performing security poll: "<<e.reason<<endl;
         }
         catch(ImmediateServFailException &e)
         {
-          L<<Logger::Error<<"Exception while performing security poll: "<<e.reason<<endl;
+          g_log<<Logger::Error<<"Exception while performing security poll: "<<e.reason<<endl;
         }
         catch(...)
         {
-          L<<Logger::Error<<"Exception while performing security poll"<<endl;
+          g_log<<Logger::Error<<"Exception while performing security poll"<<endl;
         }
 
       }
@@ -2206,7 +2206,7 @@ static void houseKeeping(void *)
   catch(PDNSException& ae)
     {
       s_running=false;
-      L<<Logger::Error<<"Fatal error in housekeeping thread: "<<ae.reason<<endl;
+      g_log<<Logger::Error<<"Fatal error in housekeeping thread: "<<ae.reason<<endl;
       throw;
     }
 }
@@ -2301,11 +2301,11 @@ static void handlePipeRequest(int fd, FDMultiplexer::f
   }
   catch(std::exception& e) {
     if(g_logCommonErrors)
-      L<<Logger::Error<<"PIPE function we executed created exception: "<<e.what()<<endl; // but what if they wanted an answer.. we send 0
+      g_log<<Logger::Error<<"PIPE function we executed created exception: "<<e.what()<<endl; // but what if they wanted an answer.. we send 0
   }
   catch(PDNSException& e) {
     if(g_logCommonErrors)
-      L<<Logger::Error<<"PIPE function we executed created PDNS exception: "<<e.reason<<endl; // but what if they wanted an answer.. we send 0
+      g_log<<Logger::Error<<"PIPE function we executed created PDNS exception: "<<e.reason<<endl; // but what if they wanted an answer.. we send 0
   }
   if(tmsg->wantAnswer) {
     if(write(g_pipes[t_id].writeFromThread, &resp, sizeof(resp)) != sizeof(resp)) {
@@ -2406,10 +2406,10 @@ static void handleRCC(int fd, FDMultiplexer::funcparam
     command();
   }
   catch(std::exception& e) {
-    L<<Logger::Error<<"Error dealing with control socket request: "<<e.what()<<endl;
+    g_log<<Logger::Error<<"Error dealing with control socket request: "<<e.what()<<endl;
   }
   catch(PDNSException& ae) {
-    L<<Logger::Error<<"Error dealing with control socket request: "<<ae.reason<<endl;
+    g_log<<Logger::Error<<"Error dealing with control socket request: "<<ae.reason<<endl;
   }
 }
 
@@ -2496,7 +2496,7 @@ static void handleUDPServerResponse(int fd, FDMultiple
     else {
       g_stats.serverParseError++;
       if(g_logCommonErrors)
-        L<<Logger::Error<<"Unable to parse packet from remote UDP server "<< fromaddr.toString() <<
+        g_log<<Logger::Error<<"Unable to parse packet from remote UDP server "<< fromaddr.toString() <<
           ": packet smaller than DNS header"<<endl;
     }
 
@@ -2520,7 +2520,7 @@ static void handleUDPServerResponse(int fd, FDMultiple
   pident.fd=fd;
 
   if(!dh.qr && g_logCommonErrors) {
-    L<<Logger::Notice<<"Not taking data from question on outgoing socket from "<< fromaddr.toStringWithPort()  <<endl;
+    g_log<<Logger::Notice<<"Not taking data from question on outgoing socket from "<< fromaddr.toStringWithPort()  <<endl;
   }
 
   if(!dh.qdcount || // UPC, Nominum, very old BIND on FormErr, NSD
@@ -2535,7 +2535,7 @@ static void handleUDPServerResponse(int fd, FDMultiple
     }
     catch(std::exception& e) {
       g_stats.serverParseError++; // won't be fed to lwres.cc, so we have to increment
-      L<<Logger::Warning<<"Error in packet from remote nameserver "<< fromaddr.toStringWithPort() << ": "<<e.what() << endl;
+      g_log<<Logger::Warning<<"Error in packet from remote nameserver "<< fromaddr.toStringWithPort() << ": "<<e.what() << endl;
       return;
     }
   }
@@ -2568,7 +2568,7 @@ retryWithName:
     }
     g_stats.unexpectedCount++; // if we made it here, it really is an unexpected answer
     if(g_logCommonErrors) {
-      L<<Logger::Warning<<"Discarding unexpected packet from "<<fromaddr.toStringWithPort()<<": "<< (pident.domain.empty() ? "<empty>" : pident.domain.toString())<<", "<<pident.type<<", "<<MT->d_waiters.size()<<" waiters"<<endl;
+      g_log<<Logger::Warning<<"Discarding unexpected packet from "<<fromaddr.toStringWithPort()<<": "<< (pident.domain.empty() ? "<empty>" : pident.domain.toString())<<", "<<pident.type<<", "<<MT->d_waiters.size()<<" waiters"<<endl;
     }
   }
   else if(fd >= 0) {
@@ -2585,13 +2585,13 @@ FDMultiplexer* getMultiplexer()
       return ret;
     }
     catch(FDMultiplexerException &fe) {
-      L<<Logger::Error<<"Non-fatal error initializing possible multiplexer ("<<fe.what()<<"), falling back"<<endl;
+      g_log<<Logger::Error<<"Non-fatal error initializing possible multiplexer ("<<fe.what()<<"), falling back"<<endl;
     }
     catch(...) {
-      L<<Logger::Error<<"Non-fatal error initializing possible multiplexer"<<endl;
+      g_log<<Logger::Error<<"Non-fatal error initializing possible multiplexer"<<endl;
     }
   }
-  L<<Logger::Error<<"No working multiplexer found!"<<endl;
+  g_log<<Logger::Error<<"No working multiplexer found!"<<endl;
   exit(1);
 }
 
@@ -2602,7 +2602,7 @@ static string* doReloadLuaScript()
   try {
     if(fname.empty()) {
       t_pdl.reset();
-      L<<Logger::Error<<t_id<<" Unloaded current lua script"<<endl;
+      g_log<<Logger::Error<<t_id<<" Unloaded current lua script"<<endl;
       return new string("unloaded\n");
     }
     else {
@@ -2610,11 +2610,11 @@ static string* doReloadLuaScript()
     }
   }
   catch(std::exception& e) {
-    L<<Logger::Error<<t_id<<" Retaining current script, error from '"<<fname<<"': "<< e.what() <<endl;
+    g_log<<Logger::Error<<t_id<<" Retaining current script, error from '"<<fname<<"': "<< e.what() <<endl;
     return new string("retaining current script, error from '"+fname+"': "+e.what()+"\n");
   }
 
-  L<<Logger::Warning<<t_id<<" (Re)loaded lua script from '"<<fname<<"'"<<endl;
+  g_log<<Logger::Warning<<t_id<<" (Re)loaded lua script from '"<<fname<<"'"<<endl;
   return new string("(re)loaded '"+fname+"'\n");
 }
 
@@ -2655,7 +2655,7 @@ static void checkLinuxIPv6Limits()
   if(readFileIfThere("/proc/sys/net/ipv6/route/max_size", &line)) {
     int lim=std::stoi(line);
     if(lim < 16384) {
-      L<<Logger::Error<<"If using IPv6, please raise sysctl net.ipv6.route.max_size, currently set to "<<lim<<" which is < 16384"<<endl;
+      g_log<<Logger::Error<<"If using IPv6, please raise sysctl net.ipv6.route.max_size, currently set to "<<lim<<" which is < 16384"<<endl;
     }
   }
 #endif
@@ -2669,11 +2669,11 @@ static void checkOrFixFDS()
     unsigned int hardlimit= getFilenumLimit(true);
     if(hardlimit >= wantFDs) {
       setFilenumLimit(wantFDs);
-      L<<Logger::Warning<<"Raised soft limit on number of filedescriptors to "<<wantFDs<<" to match max-mthreads and threads settings"<<endl;
+      g_log<<Logger::Warning<<"Raised soft limit on number of filedescriptors to "<<wantFDs<<" to match max-mthreads and threads settings"<<endl;
     }
     else {
       int newval = (hardlimit - 25) / g_numWorkerThreads;
-      L<<Logger::Warning<<"Insufficient number of filedescriptors available for max-mthreads*threads setting! ("<<hardlimit<<" < "<<wantFDs<<"), reducing max-mthreads to "<<newval<<endl;
+      g_log<<Logger::Warning<<"Insufficient number of filedescriptors available for max-mthreads*threads setting! ("<<hardlimit<<" < "<<wantFDs<<"), reducing max-mthreads to "<<newval<<endl;
       g_maxMThreads = newval;
       setFilenumLimit(hardlimit);
     }
@@ -2744,24 +2744,24 @@ void parseACLs()
 
       allowFrom->addMask(line);
     }
-    L<<Logger::Warning<<"Done parsing " << allowFrom->size() <<" allow-from ranges from file '"<<::arg()["allow-from-file"]<<"' - overriding 'allow-from' setting"<<endl;
+    g_log<<Logger::Warning<<"Done parsing " << allowFrom->size() <<" allow-from ranges from file '"<<::arg()["allow-from-file"]<<"' - overriding 'allow-from' setting"<<endl;
   }
   else if(!::arg()["allow-from"].empty()) {
     vector<string> ips;
     stringtok(ips, ::arg()["allow-from"], ", ");
 
-    L<<Logger::Warning<<"Only allowing queries from: ";
+    g_log<<Logger::Warning<<"Only allowing queries from: ";
     for(vector<string>::const_iterator i = ips.begin(); i!= ips.end(); ++i) {
       allowFrom->addMask(*i);
       if(i!=ips.begin())
-        L<<Logger::Warning<<", ";
-      L<<Logger::Warning<<*i;
+        g_log<<Logger::Warning<<", ";
+      g_log<<Logger::Warning<<*i;
     }
-    L<<Logger::Warning<<endl;
+    g_log<<Logger::Warning<<endl;
   }
   else {
     if(::arg()["local-address"]!="127.0.0.1" && ::arg().asNum("local-port")==53)
-      L<<Logger::Error<<"WARNING: Allowing queries from all IP addresses - this can be a security risk!"<<endl;
+      g_log<<Logger::Error<<"WARNING: Allowing queries from all IP addresses - this can be a security risk!"<<endl;
     allowFrom = nullptr;
   }
 
@@ -2789,7 +2789,7 @@ static std::map<unsigned int, std::set<int> > parseCPU
   const std::string value = ::arg()["cpu-map"];
 
   if (!value.empty() && !isSettingThreadCPUAffinitySupported()) {
-    L<<Logger::Warning<<"CPU mapping requested but not supported, skipping"<<endl;
+    g_log<<Logger::Warning<<"CPU mapping requested but not supported, skipping"<<endl;
     return result;
   }
 
@@ -2818,7 +2818,7 @@ static std::map<unsigned int, std::set<int> > parseCPU
       }
     }
     catch(const std::exception& e) {
-      L<<Logger::Error<<"Error parsing cpu-map entry '"<<part<<"': "<<e.what()<<endl;
+      g_log<<Logger::Error<<"Error parsing cpu-map entry '"<<part<<"': "<<e.what()<<endl;
     }
   }
 
@@ -2831,34 +2831,34 @@ static void setCPUMap(const std::map<unsigned int, std
   if (cpuMapping != cpusMap.cend()) {
     int rc = mapThreadToCPUList(tid, cpuMapping->second);
     if (rc == 0) {
-      L<<Logger::Info<<"CPU affinity for worker "<<n<<" has been set to CPU map:";
+      g_log<<Logger::Info<<"CPU affinity for worker "<<n<<" has been set to CPU map:";
       for (const auto cpu : cpuMapping->second) {
-        L<<Logger::Info<<" "<<cpu;
+        g_log<<Logger::Info<<" "<<cpu;
       }
-      L<<Logger::Info<<endl;
+      g_log<<Logger::Info<<endl;
     }
     else {
-      L<<Logger::Warning<<"Error setting CPU affinity for worker "<<n<<" to CPU map:";
+      g_log<<Logger::Warning<<"Error setting CPU affinity for worker "<<n<<" to CPU map:";
       for (const auto cpu : cpuMapping->second) {
-        L<<Logger::Info<<" "<<cpu;
+        g_log<<Logger::Info<<" "<<cpu;
       }
-      L<<Logger::Info<<strerror(rc)<<endl;
+      g_log<<Logger::Info<<strerror(rc)<<endl;
     }
   }
 }
 
 static int serviceMain(int argc, char*argv[])
 {
-  L.setName(s_programname);
-  L.disableSyslog(::arg().mustDo("disable-syslog"));
-  L.setTimestamps(::arg().mustDo("log-timestamp"));
+  g_log.setName(s_programname);
+  g_log.disableSyslog(::arg().mustDo("disable-syslog"));
+  g_log.setTimestamps(::arg().mustDo("log-timestamp"));
 
   if(!::arg()["logging-facility"].empty()) {
     int val=logFacilityToLOG(::arg().asNum("logging-facility") );
     if(val >= 0)
-      theL().setFacility(val);
+      g_log.setFacility(val);
     else
-      L<<Logger::Error<<"Unknown logging facility "<<::arg().asNum("logging-facility") <<endl;
+      g_log<<Logger::Error<<"Unknown logging facility "<<::arg().asNum("logging-facility") <<endl;
   }
 
   showProductVersion();
@@ -2871,7 +2871,7 @@ static int serviceMain(int argc, char*argv[])
     vector<string> addrs;
     if(!::arg()["query-local-address6"].empty()) {
       SyncRes::s_doIPv6=true;
-      L<<Logger::Warning<<"Enabling IPv6 transport for outgoing queries"<<endl;
+      g_log<<Logger::Warning<<"Enabling IPv6 transport for outgoing queries"<<endl;
 
       stringtok(addrs, ::arg()["query-local-address6"], ", ;");
       for(const string& addr : addrs) {
@@ -2879,7 +2879,7 @@ static int serviceMain(int argc, char*argv[])
       }
     }
     else {
-      L<<Logger::Warning<<"NOT using IPv6 for outgoing queries - set 'query-local-address6=::' to enable"<<endl;
+      g_log<<Logger::Warning<<"NOT using IPv6 for outgoing queries - set 'query-local-address6=::' to enable"<<endl;
     }
     addrs.clear();
     stringtok(addrs, ::arg()["query-local-address"], ", ;");
@@ -2888,7 +2888,7 @@ static int serviceMain(int argc, char*argv[])
     }
   }
   catch(std::exception& e) {
-    L<<Logger::Error<<"Assigning local query addresses: "<<e.what();
+    g_log<<Logger::Error<<"Assigning local query addresses: "<<e.what();
     exit(99);
   }
 
@@ -2904,7 +2904,7 @@ static int serviceMain(int argc, char*argv[])
   else if(::arg()["dnssec"]=="log-fail")
     g_dnssecmode=DNSSECMode::ValidateForLog;
   else {
-    L<<Logger::Error<<"Unknown DNSSEC mode "<<::arg()["dnssec"]<<endl;
+    g_log<<Logger::Error<<"Unknown DNSSEC mode "<<::arg()["dnssec"]<<endl;
     exit(1);
   }
 
@@ -2918,7 +2918,7 @@ static int serviceMain(int argc, char*argv[])
     loadRecursorLuaConfig(::arg()["lua-config-file"], ::arg().mustDo("daemon"));
   }
   catch (PDNSException &e) {
-    L<<Logger::Error<<"Cannot load Lua configuration: "<<e.reason<<endl;
+    g_log<<Logger::Error<<"Cannot load Lua configuration: "<<e.reason<<endl;
     exit(1);
   }
 
@@ -2931,21 +2931,21 @@ static int serviceMain(int argc, char*argv[])
     ips.push_back("0.0.0.0");
     ips.push_back("::");
 
-    L<<Logger::Warning<<"Will not send queries to: ";
+    g_log<<Logger::Warning<<"Will not send queries to: ";
     for(vector<string>::const_iterator i = ips.begin(); i!= ips.end(); ++i) {
       SyncRes::addDontQuery(*i);
       if(i!=ips.begin())
-        L<<Logger::Warning<<", ";
-      L<<Logger::Warning<<*i;
+        g_log<<Logger::Warning<<", ";
+      g_log<<Logger::Warning<<*i;
     }
-    L<<Logger::Warning<<endl;
+    g_log<<Logger::Warning<<endl;
   }
 
   g_quiet=::arg().mustDo("quiet");
 
   g_weDistributeQueries = ::arg().mustDo("pdns-distributes-queries");
   if(g_weDistributeQueries) {
-      L<<Logger::Warning<<"PowerDNS Recursor itself will distribute queries over threads"<<endl;
+      g_log<<Logger::Warning<<"PowerDNS Recursor itself will distribute queries over threads"<<endl;
   }
 
   setupDelegationOnly();
@@ -3030,7 +3030,7 @@ static int serviceMain(int argc, char*argv[])
 
   g_numWorkerThreads = ::arg().asNum("threads");
   if (g_numWorkerThreads < 1) {
-    L<<Logger::Warning<<"Asked to run with 0 threads, raising to 1 instead"<<endl;
+    g_log<<Logger::Warning<<"Asked to run with 0 threads, raising to 1 instead"<<endl;
     g_numWorkerThreads = 1;
   }
 
@@ -3068,8 +3068,8 @@ static int serviceMain(int argc, char*argv[])
   }
 
   if(::arg().mustDo("daemon")) {
-    L<<Logger::Warning<<"Calling daemonize, going to background"<<endl;
-    L.toConsole(Logger::Critical);
+    g_log<<Logger::Warning<<"Calling daemonize, going to background"<<endl;
+    g_log.toConsole(Logger::Critical);
     daemonize();
     loadRecursorLuaConfig(::arg()["lua-config-file"], false);
   }
@@ -3081,7 +3081,7 @@ static int serviceMain(int argc, char*argv[])
 
 #ifdef HAVE_LIBSODIUM
   if (sodium_init() == -1) {
-    L<<Logger::Error<<"Unable to initialize sodium crypto library"<<endl;
+    g_log<<Logger::Error<<"Unable to initialize sodium crypto library"<<endl;
     exit(99);
   }
 #endif
@@ -3103,16 +3103,16 @@ static int serviceMain(int argc, char*argv[])
      char *ns;
      ns = getenv("NOTIFY_SOCKET");
      if (ns != nullptr) {
-       L<<Logger::Error<<"Unable to chroot when running from systemd. Please disable chroot= or set the 'Type' for this service to 'simple'"<<endl;
+       g_log<<Logger::Error<<"Unable to chroot when running from systemd. Please disable chroot= or set the 'Type' for this service to 'simple'"<<endl;
        exit(1);
      }
 #endif
     if (chroot(::arg()["chroot"].c_str())<0 || chdir("/") < 0) {
-      L<<Logger::Error<<"Unable to chroot to '"+::arg()["chroot"]+"': "<<strerror (errno)<<", exiting"<<endl;
+      g_log<<Logger::Error<<"Unable to chroot to '"+::arg()["chroot"]+"': "<<strerror (errno)<<", exiting"<<endl;
       exit(1);
     }
     else
-      L<<Logger::Error<<"Chrooted to '"<<::arg()["chroot"]<<"'"<<endl;
+      g_log<<Logger::Error<<"Chrooted to '"<<::arg()["chroot"]<<"'"<<endl;
   }
 
   s_pidfname=::arg()["socket-dir"]+"/"+s_programname+".pid";
@@ -3137,7 +3137,7 @@ static int serviceMain(int argc, char*argv[])
 
   const auto cpusMap = parseCPUMap();
   if(g_numThreads == 1) {
-    L<<Logger::Warning<<"Operating unthreaded"<<endl;
+    g_log<<Logger::Warning<<"Operating unthreaded"<<endl;
 #ifdef HAVE_SYSTEMD
     sd_notify(0, "READY=1");
 #endif
@@ -3146,7 +3146,7 @@ static int serviceMain(int argc, char*argv[])
   }
   else {
     pthread_t tid;
-    L<<Logger::Warning<<"Launching "<< g_numThreads <<" threads"<<endl;
+    g_log<<Logger::Warning<<"Launching "<< g_numThreads <<" threads"<<endl;
     for(unsigned int n=0; n < g_numThreads; ++n) {
       pthread_create(&tid, 0, recursorThread, (void*)(long)n);
 
@@ -3177,16 +3177,16 @@ try
 #ifdef HAVE_PROTOBUF
   t_uuidGenerator = std::unique_ptr<boost::uuids::random_generator>(new boost::uuids::random_generator());
 #endif
-  L<<Logger::Warning<<"Done priming cache with root hints"<<endl;
+  g_log<<Logger::Warning<<"Done priming cache with root hints"<<endl;
 
   try {
     if(!::arg()["lua-dns-script"].empty()) {
       t_pdl = std::make_shared<RecursorLua4>(::arg()["lua-dns-script"]);
-      L<<Logger::Warning<<"Loaded 'lua' script from '"<<::arg()["lua-dns-script"]<<"'"<<endl;
+      g_log<<Logger::Warning<<"Loaded 'lua' script from '"<<::arg()["lua-dns-script"]<<"'"<<endl;
     }
   }
   catch(std::exception &e) {
-    L<<Logger::Error<<"Failed to load 'lua' script from '"<<::arg()["lua-dns-script"]<<"': "<<e.what()<<endl;
+    g_log<<Logger::Error<<"Failed to load 'lua' script from '"<<::arg()["lua-dns-script"]<<"': "<<e.what()<<endl;
     _exit(99);
   }
 
@@ -3215,16 +3215,16 @@ try
   t_fdm=getMultiplexer();
   if(!t_id) {
     if(::arg().mustDo("webserver")) {
-      L<<Logger::Warning << "Enabling web server" << endl;
+      g_log<<Logger::Warning << "Enabling web server" << endl;
       try {
         new RecursorWebServer(t_fdm);
       }
       catch(PDNSException &e) {
-        L<<Logger::Error<<"Exception: "<<e.reason<<endl;
+        g_log<<Logger::Error<<"Exception: "<<e.reason<<endl;
         exit(99);
       }
     }
-    L<<Logger::Error<<"Enabled '"<< t_fdm->getName() << "' multiplexer"<<endl;
+    g_log<<Logger::Error<<"Enabled '"<< t_fdm->getName() << "' multiplexer"<<endl;
   }
 
   t_fdm->addReadFD(g_pipes[t_id].readToThread, handlePipeRequest);
@@ -3268,7 +3268,7 @@ try
       for(expired_t::iterator i=expired.begin() ; i != expired.end(); ++i) {
         shared_ptr<TCPConnection> conn=any_cast<shared_ptr<TCPConnection> >(i->second);
         if(g_logCommonErrors)
-          L<<Logger::Warning<<"Timeout from remote TCP client "<< conn->d_remote.toString() <<endl;
+          g_log<<Logger::Warning<<"Timeout from remote TCP client "<< conn->d_remote.toString() <<endl;
         t_fdm->removeReadFD(i->first);
       }
     }
@@ -3308,15 +3308,15 @@ try
   }
 }
 catch(PDNSException &ae) {
-  L<<Logger::Error<<"Exception: "<<ae.reason<<endl;
+  g_log<<Logger::Error<<"Exception: "<<ae.reason<<endl;
   return 0;
 }
 catch(std::exception &e) {
-   L<<Logger::Error<<"STL Exception: "<<e.what()<<endl;
+   g_log<<Logger::Error<<"STL Exception: "<<e.what()<<endl;
    return 0;
 }
 catch(...) {
-   L<<Logger::Error<<"any other exception in main: "<<endl;
+   g_log<<Logger::Error<<"any other exception in main: "<<endl;
    return 0;
 }
 
@@ -3450,7 +3450,7 @@ int main(int argc, char **argv)
     ::arg().setCmd("help","Provide a helpful message");
     ::arg().setCmd("version","Print version string");
     ::arg().setCmd("config","Output blank configuration");
-    L.toConsole(Logger::Info);
+    g_log.toConsole(Logger::Info);
     ::arg().laxParse(argc,argv); // do a lax parse
 
     string configname=::arg()["config-dir"]+"/recursor.conf";
@@ -3466,12 +3466,12 @@ int main(int argc, char **argv)
     }
 
     if(!::arg().file(configname.c_str()))
-      L<<Logger::Warning<<"Unable to parse configuration file '"<<configname<<"'"<<endl;
+      g_log<<Logger::Warning<<"Unable to parse configuration file '"<<configname<<"'"<<endl;
 
     ::arg().parse(argc,argv);
 
     if( !::arg()["chroot"].empty() && !::arg()["api-config-dir"].empty() && !::arg().mustDo("api-readonly") )  {
-      L<<Logger::Error<<"Using chroot and a writable API is not possible"<<endl;
+      g_log<<Logger::Error<<"Using chroot and a writable API is not possible"<<endl;
       exit(EXIT_FAILURE);
     }
 
@@ -3505,21 +3505,21 @@ int main(int argc, char **argv)
     if(!g_quiet && logUrgency < Logger::Info) { // Logger::Info=6, Logger::Debug=7
       logUrgency = Logger::Info;                // if you do --quiet=no, you need Info to also see the query log
     }
-    L.setLoglevel(logUrgency);
-    L.toConsole(logUrgency);
+    g_log.setLoglevel(logUrgency);
+    g_log.toConsole(logUrgency);
 
     serviceMain(argc, argv);
   }
   catch(PDNSException &ae) {
-    L<<Logger::Error<<"Exception: "<<ae.reason<<endl;
+    g_log<<Logger::Error<<"Exception: "<<ae.reason<<endl;
     ret=EXIT_FAILURE;
   }
   catch(std::exception &e) {
-    L<<Logger::Error<<"STL Exception: "<<e.what()<<endl;
+    g_log<<Logger::Error<<"STL Exception: "<<e.what()<<endl;
     ret=EXIT_FAILURE;
   }
   catch(...) {
-    L<<Logger::Error<<"any other exception in main: "<<endl;
+    g_log<<Logger::Error<<"any other exception in main: "<<endl;
     ret=EXIT_FAILURE;
   }
 
--- randomhelper.cc.orig	2018-03-29 13:04:45 UTC
+++ randomhelper.cc
@@ -11,11 +11,11 @@
 
 void seedRandom(const string& source)
 {
-  L<<Logger::Warning<<"Reading random entropy from '"<<source<<"'"<<endl;
+  g_log<<Logger::Warning<<"Reading random entropy from '"<<source<<"'"<<endl;
 
   int fd=open(source.c_str(), O_RDONLY);
   if(fd < 0) {
-    L<<Logger::Error<<"Unable to open source of random '"<<source<<"': "<<stringerror()<<endl;
+    g_log<<Logger::Error<<"Unable to open source of random '"<<source<<"': "<<stringerror()<<endl;
     exit(EXIT_FAILURE);
   }
   char seed[16];
@@ -24,12 +24,12 @@ void seedRandom(const string& source)
   while(pos!=sizeof(seed)) {
     ret = read(fd, seed+pos, sizeof(seed)-pos);
     if(ret < 0) { 
-      L<<Logger::Error<<"Unable to read random seed from "<<source<<": "<<stringerror()<<endl;
+      g_log<<Logger::Error<<"Unable to read random seed from "<<source<<": "<<stringerror()<<endl;
       close(fd);
       exit(EXIT_FAILURE);
     }
     if(!ret) {
-      L<<Logger::Error<<"Unable to read random seed from "<<source<<": end of file"<<endl;
+      g_log<<Logger::Error<<"Unable to read random seed from "<<source<<": end of file"<<endl;
       close(fd);
       exit(EXIT_FAILURE);
     }
--- rec-carbon.cc.orig	2018-03-29 13:04:45 UTC
+++ rec-carbon.cc
@@ -60,20 +60,20 @@ try
 
     int ret=asendtcp(msg, &s);     // this will actually do the right thing waiting on the connect
     if(ret < 0)
-      L<<Logger::Warning<<"Error writing carbon data to "<<remote.toStringWithPort()<<": "<<strerror(errno)<<endl;
+      g_log<<Logger::Warning<<"Error writing carbon data to "<<remote.toStringWithPort()<<": "<<strerror(errno)<<endl;
     if(ret==0)
-      L<<Logger::Warning<<"Timeout connecting/writing carbon data to "<<remote.toStringWithPort()<<endl;
+      g_log<<Logger::Warning<<"Timeout connecting/writing carbon data to "<<remote.toStringWithPort()<<endl;
   }
  }
 catch(PDNSException& e)
 {
-  L<<Logger::Error<<"Error in carbon thread: "<<e.reason<<endl;
+  g_log<<Logger::Error<<"Error in carbon thread: "<<e.reason<<endl;
 }
 catch(std::exception& e)
 {
-  L<<Logger::Error<<"Error in carbon thread: "<<e.what()<<endl;
+  g_log<<Logger::Error<<"Error in carbon thread: "<<e.what()<<endl;
 }
 catch(...)
 {
-  L<<Logger::Error<<"Unknown error in carbon thread"<<endl;
+  g_log<<Logger::Error<<"Unknown error in carbon thread"<<endl;
 }
--- rec-lua-conf.cc.orig	2018-03-29 13:04:45 UTC
+++ rec-lua-conf.cc
@@ -123,14 +123,14 @@ void loadRecursorLuaConfig(const std::string& fname, b
             zone->reserve(zoneSizeHint);
           }
         }
-        theL()<<Logger::Warning<<"Loading RPZ from file '"<<filename<<"'"<<endl;
+        g_log<<Logger::Warning<<"Loading RPZ from file '"<<filename<<"'"<<endl;
         zone->setName(polName);
         loadRPZFromFile(filename, zone, defpol, maxTTL);
         lci.dfe.addZone(zone);
-        theL()<<Logger::Warning<<"Done loading RPZ from file '"<<filename<<"'"<<endl;
+        g_log<<Logger::Warning<<"Done loading RPZ from file '"<<filename<<"'"<<endl;
       }
       catch(const std::exception& e) {
-        theL()<<Logger::Error<<"Unable to load RPZ zone from '"<<filename<<"': "<<e.what()<<endl;
+        g_log<<Logger::Error<<"Unable to load RPZ zone from '"<<filename<<"': "<<e.what()<<endl;
       }
     });
 
@@ -186,11 +186,11 @@ void loadRecursorLuaConfig(const std::string& fname, b
         zoneIdx = lci.dfe.addZone(zone);
       }
       catch(const std::exception& e) {
-        theL()<<Logger::Error<<"Problem configuring 'rpzMaster': "<<e.what()<<endl;
+        g_log<<Logger::Error<<"Problem configuring 'rpzMaster': "<<e.what()<<endl;
         exit(1);  // FIXME proper exit code?
       }
       catch(const PDNSException& e) {
-        theL()<<Logger::Error<<"Problem configuring 'rpzMaster': "<<e.reason<<endl;
+        g_log<<Logger::Error<<"Problem configuring 'rpzMaster': "<<e.reason<<endl;
         exit(1);  // FIXME proper exit code?
       }
 
@@ -201,11 +201,11 @@ void loadRecursorLuaConfig(const std::string& fname, b
         }
       }
       catch(const std::exception& e) {
-        theL()<<Logger::Error<<"Problem starting RPZIXFRTracker thread: "<<e.what()<<endl;
+        g_log<<Logger::Error<<"Problem starting RPZIXFRTracker thread: "<<e.what()<<endl;
         exit(1);  // FIXME proper exit code?
       }
       catch(const PDNSException& e) {
-        theL()<<Logger::Error<<"Problem starting RPZIXFRTracker thread: "<<e.reason<<endl;
+        g_log<<Logger::Error<<"Problem starting RPZIXFRTracker thread: "<<e.reason<<endl;
         exit(1);  // FIXME proper exit code?
       }
     });
@@ -238,7 +238,7 @@ void loadRecursorLuaConfig(const std::string& fname, b
 			}
 		      }
 		      catch(std::exception& e) {
-			theL()<<Logger::Error<<"Error in addSortList: "<<e.what()<<endl;
+			g_log<<Logger::Error<<"Error in addSortList: "<<e.what()<<endl;
 		      }
 		    });
 
@@ -293,14 +293,14 @@ void loadRecursorLuaConfig(const std::string& fname, b
           }
         }
         else {
-          theL()<<Logger::Error<<"Only one protobuf server can be configured, we already have "<<lci.protobufServer->toString()<<endl;
+          g_log<<Logger::Error<<"Only one protobuf server can be configured, we already have "<<lci.protobufServer->toString()<<endl;
         }
       }
       catch(std::exception& e) {
-	theL()<<Logger::Error<<"Error while starting protobuf logger to '"<<server_<<": "<<e.what()<<endl;
+	g_log<<Logger::Error<<"Error while starting protobuf logger to '"<<server_<<": "<<e.what()<<endl;
       }
       catch(PDNSException& e) {
-        theL()<<Logger::Error<<"Error while starting protobuf logger to '"<<server_<<": "<<e.reason<<endl;
+        g_log<<Logger::Error<<"Error while starting protobuf logger to '"<<server_<<": "<<e.reason<<endl;
       }
     });
 
@@ -313,14 +313,14 @@ void loadRecursorLuaConfig(const std::string& fname, b
           }
         }
         else {
-          theL()<<Logger::Error<<"Only one protobuf server can be configured, we already have "<<lci.protobufServer->toString()<<endl;
+          g_log<<Logger::Error<<"Only one protobuf server can be configured, we already have "<<lci.protobufServer->toString()<<endl;
         }
       }
       catch(std::exception& e) {
-	theL()<<Logger::Error<<"Error while starting protobuf logger to '"<<server_<<": "<<e.what()<<endl;
+	g_log<<Logger::Error<<"Error while starting protobuf logger to '"<<server_<<": "<<e.what()<<endl;
       }
       catch(PDNSException& e) {
-        theL()<<Logger::Error<<"Error while starting protobuf logger to '"<<server_<<": "<<e.reason<<endl;
+        g_log<<Logger::Error<<"Error while starting protobuf logger to '"<<server_<<": "<<e.reason<<endl;
       }
     });
 #endif
@@ -330,22 +330,22 @@ void loadRecursorLuaConfig(const std::string& fname, b
     g_luaconfs.setState(lci);
   }
   catch(const LuaContext::ExecutionErrorException& e) {
-    theL()<<Logger::Error<<"Unable to load Lua script from '"+fname+"': ";
+    g_log<<Logger::Error<<"Unable to load Lua script from '"+fname+"': ";
     try {
       std::rethrow_if_nested(e);
     } catch(const std::exception& exp) {
       // exp is the exception that was thrown from inside the lambda
-      theL() << exp.what() << std::endl;
+      g_log << exp.what() << std::endl;
     }
     catch(const PDNSException& exp) {
       // exp is the exception that was thrown from inside the lambda
-      theL() << exp.reason << std::endl;
+      g_log << exp.reason << std::endl;
     }
     throw;
 
   }
   catch(std::exception& err) {
-    theL()<<Logger::Error<<"Unable to load Lua script from '"+fname+"': "<<err.what()<<endl;
+    g_log<<Logger::Error<<"Unable to load Lua script from '"+fname+"': "<<err.what()<<endl;
     throw;
   }
 
--- rec-snmp.cc.orig	2018-03-29 13:04:45 UTC
+++ rec-snmp.cc
@@ -144,12 +144,12 @@ static int handleCounter64Stats(netsnmp_mib_handler* h
 static void registerCounter64Stat(const char* name, const oid statOID[], size_t statOIDLength)
 {
   if (statOIDLength != OID_LENGTH(questionsOID)) {
-    L<<Logger::Error<<"Invalid OID for SNMP Counter64 statistic "<<std::string(name)<<endl;
+    g_log<<Logger::Error<<"Invalid OID for SNMP Counter64 statistic "<<std::string(name)<<endl;
     return;
   }
 
   if (s_statsMap.find(statOID[statOIDLength - 1]) != s_statsMap.end()) {
-    L<<Logger::Error<<"OID for SNMP Counter64 statistic "<<std::string(name)<<" has already been registered"<<endl;
+    g_log<<Logger::Error<<"OID for SNMP Counter64 statistic "<<std::string(name)<<" has already been registered"<<endl;
     return;
   }
 
--- rec_channel_rec.cc.orig	2018-03-29 13:04:45 UTC
+++ rec_channel_rec.cc
@@ -389,7 +389,7 @@ string doSetDnssecLogBogus(T begin, T end)
 
   if (pdns_iequals(*begin, "on") || pdns_iequals(*begin, "yes")) {
     if (!g_dnssecLogBogus) {
-      L<<Logger::Warning<<"Enabling DNSSEC Bogus logging, requested via control channel"<<endl;
+      g_log<<Logger::Warning<<"Enabling DNSSEC Bogus logging, requested via control channel"<<endl;
       g_dnssecLogBogus = true;
       return "DNSSEC Bogus logging enabled\n";
     }
@@ -398,7 +398,7 @@ string doSetDnssecLogBogus(T begin, T end)
 
   if (pdns_iequals(*begin, "off") || pdns_iequals(*begin, "no")) {
     if (g_dnssecLogBogus) {
-      L<<Logger::Warning<<"Disabling DNSSEC Bogus logging, requested via control channel"<<endl;
+      g_log<<Logger::Warning<<"Disabling DNSSEC Bogus logging, requested via control channel"<<endl;
       g_dnssecLogBogus = false;
       return "DNSSEC Bogus logging disabled\n";
     }
@@ -436,7 +436,7 @@ string doAddNTA(T begin, T end)
     if (begin != end)
       why += " ";
   }
-  L<<Logger::Warning<<"Adding Negative Trust Anchor for "<<who<<" with reason '"<<why<<"', requested via control channel"<<endl;
+  g_log<<Logger::Warning<<"Adding Negative Trust Anchor for "<<who<<" with reason '"<<why<<"', requested via control channel"<<endl;
   g_luaconfs.modify([who, why](LuaConfigItems& lci) {
       lci.negAnchors[who] = why;
       });
@@ -454,7 +454,7 @@ string doClearNTA(T begin, T end)
     return "No Negative Trust Anchor specified, doing nothing.\n";
 
   if (begin + 1 == end && *begin == "*"){
-    L<<Logger::Warning<<"Clearing all Negative Trust Anchors, requested via control channel"<<endl;
+    g_log<<Logger::Warning<<"Clearing all Negative Trust Anchors, requested via control channel"<<endl;
     g_luaconfs.modify([](LuaConfigItems& lci) {
         lci.negAnchors.clear();
       });
@@ -482,7 +482,7 @@ string doClearNTA(T begin, T end)
   string removed("");
   bool first(true);
   for (auto const &entry : toRemove) {
-    L<<Logger::Warning<<"Clearing Negative Trust Anchor for "<<entry<<", requested via control channel"<<endl;
+    g_log<<Logger::Warning<<"Clearing Negative Trust Anchor for "<<entry<<", requested via control channel"<<endl;
     g_luaconfs.modify([entry](LuaConfigItems& lci) {
         lci.negAnchors.erase(entry);
       });
@@ -536,17 +536,17 @@ string doAddTA(T begin, T end)
   }
 
   try {
-    L<<Logger::Warning<<"Adding Trust Anchor for "<<who<<" with data '"<<what<<"', requested via control channel";
+    g_log<<Logger::Warning<<"Adding Trust Anchor for "<<who<<" with data '"<<what<<"', requested via control channel";
     g_luaconfs.modify([who, what](LuaConfigItems& lci) {
       auto ds = unique_ptr<DSRecordContent>(dynamic_cast<DSRecordContent*>(DSRecordContent::make(what)));
       lci.dsAnchors[who].insert(*ds);
       });
     broadcastAccFunction<uint64_t>(boost::bind(pleaseWipePacketCache, who, true));
-    L<<Logger::Warning<<endl;
+    g_log<<Logger::Warning<<endl;
     return "Added Trust Anchor for " + who.toStringRootDot() + " with data " + what + "\n";
   }
   catch(std::exception &e) {
-    L<<Logger::Warning<<", failed: "<<e.what()<<endl;
+    g_log<<Logger::Warning<<", failed: "<<e.what()<<endl;
     return "Unable to add Trust Anchor for " + who.toStringRootDot() + ": " + e.what() + "\n";
   }
 }
@@ -581,7 +581,7 @@ string doClearTA(T begin, T end)
   string removed("");
   bool first(true);
   for (auto const &entry : toRemove) {
-    L<<Logger::Warning<<"Removing Trust Anchor for "<<entry<<", requested via control channel"<<endl;
+    g_log<<Logger::Warning<<"Removing Trust Anchor for "<<entry<<", requested via control channel"<<endl;
     g_luaconfs.modify([entry](LuaConfigItems& lci) {
         lci.dsAnchors.erase(entry);
       });
@@ -987,7 +987,7 @@ void registerAllStats()
 
 static void doExitGeneric(bool nicely)
 {
-  L<<Logger::Error<<"Exiting on user request"<<endl;
+  g_log<<Logger::Error<<"Exiting on user request"<<endl;
   extern RecursorControlChannel s_rcc;
   s_rcc.~RecursorControlChannel(); 
 
@@ -1308,7 +1308,7 @@ string RecursorControlParser::getAnswer(const string& 
 
     try {
       loadRecursorLuaConfig(::arg()["lua-config-file"], false);
-      L<<Logger::Warning<<"Reloaded Lua configuration file '"<<::arg()["lua-config-file"]<<"', requested via control channel"<<endl;
+      g_log<<Logger::Warning<<"Reloaded Lua configuration file '"<<::arg()["lua-config-file"]<<"', requested via control channel"<<endl;
       return "Reloaded Lua configuration file '"+::arg()["lua-config-file"]+"'\n";
     }
     catch(std::exception& e) {
@@ -1333,7 +1333,7 @@ string RecursorControlParser::getAnswer(const string& 
 
   if(cmd=="reload-acls") {
     if(!::arg()["chroot"].empty()) {
-      L<<Logger::Error<<"Unable to reload ACL when chroot()'ed, requested via control channel"<<endl;
+      g_log<<Logger::Error<<"Unable to reload ACL when chroot()'ed, requested via control channel"<<endl;
       return "Unable to reload ACL when chroot()'ed, please restart\n";
     }
 
@@ -1342,12 +1342,12 @@ string RecursorControlParser::getAnswer(const string& 
     } 
     catch(std::exception& e) 
     {
-      L<<Logger::Error<<"Reloading ACLs failed (Exception: "<<e.what()<<")"<<endl;
+      g_log<<Logger::Error<<"Reloading ACLs failed (Exception: "<<e.what()<<")"<<endl;
       return e.what() + string("\n");
     }
     catch(PDNSException& ae)
     {
-      L<<Logger::Error<<"Reloading ACLs failed (PDNSException: "<<ae.reason<<")"<<endl;
+      g_log<<Logger::Error<<"Reloading ACLs failed (PDNSException: "<<ae.reason<<")"<<endl;
       return ae.reason + string("\n");
     }
     return "ok\n";
@@ -1386,7 +1386,7 @@ string RecursorControlParser::getAnswer(const string& 
 
   if(cmd=="reload-zones") {
     if(!::arg()["chroot"].empty()) {
-      L<<Logger::Error<<"Unable to reload zones and forwards when chroot()'ed, requested via control channel"<<endl;
+      g_log<<Logger::Error<<"Unable to reload zones and forwards when chroot()'ed, requested via control channel"<<endl;
       return "Unable to reload zones and forwards when chroot()'ed, please restart\n";
     }
     return reloadAuthAndForwards();
--- recursor_cache.hh.orig	2018-03-29 13:04:45 UTC
+++ recursor_cache.hh
@@ -30,7 +30,6 @@
 #include <iostream>
 #include "dnsrecords.hh"
 #include <boost/utility.hpp>
-#undef L
 #include <boost/multi_index_container.hpp>
 #include <boost/multi_index/ordered_index.hpp>
 #include <boost/multi_index/hashed_index.hpp>
@@ -42,7 +41,6 @@
 #include "validate.hh"
 #undef max
 
-#define L theL()
 #include "namespaces.hh"
 using namespace ::boost::multi_index;
 
--- reczones.cc.orig	2018-03-29 13:04:45 UTC
+++ reczones.cc
@@ -119,10 +119,10 @@ static void makeNameToIPZone(std::shared_ptr<SyncRes::
   ad.d_records.insert(dr);
   
   if(newMap->count(dr.d_name)) {  
-    L<<Logger::Warning<<"Hosts file will not overwrite zone '"<<dr.d_name<<"' already loaded"<<endl;
+    g_log<<Logger::Warning<<"Hosts file will not overwrite zone '"<<dr.d_name<<"' already loaded"<<endl;
   }
   else {
-    L<<Logger::Warning<<"Inserting forward zone '"<<dr.d_name<<"' based on hosts file"<<endl;
+    g_log<<Logger::Warning<<"Inserting forward zone '"<<dr.d_name<<"' based on hosts file"<<endl;
     ad.d_name=dr.d_name;
     (*newMap)[ad.d_name]=ad;
   }
@@ -165,11 +165,11 @@ static void makeIPToNamesZone(std::shared_ptr<SyncRes:
     }
 
   if(newMap->count(dr.d_name)) {  
-    L<<Logger::Warning<<"Will not overwrite zone '"<<dr.d_name<<"' already loaded"<<endl;
+    g_log<<Logger::Warning<<"Will not overwrite zone '"<<dr.d_name<<"' already loaded"<<endl;
   }
   else {
     if(ipparts.size()==4)
-      L<<Logger::Warning<<"Inserting reverse zone '"<<dr.d_name<<"' based on hosts file"<<endl;
+      g_log<<Logger::Warning<<"Inserting reverse zone '"<<dr.d_name<<"' based on hosts file"<<endl;
     ad.d_name = dr.d_name;
     (*newMap)[ad.d_name]=ad;
   }
@@ -215,15 +215,15 @@ void convertServersForAD(const std::string& input, Syn
 
   for(vector<string>::const_iterator iter = servers.begin(); iter != servers.end(); ++iter) {
     if(verbose && iter != servers.begin()) 
-      L<<", ";
+      g_log<<", ";
 
     ComboAddress addr=parseIPAndPort(*iter, 53);
     if(verbose)
-      L<<addr.toStringWithPort();
+      g_log<<addr.toStringWithPort();
     ad.d_servers.push_back(addr);
   }
   if(verbose)
-    L<<endl;
+    g_log<<endl;
 }
 
 void* pleaseWipeNegCache()
@@ -243,7 +243,7 @@ string reloadAuthAndForwards()
   std::shared_ptr<SyncRes::domainmap_t> original=SyncRes::getDomainMap();
   
   try {
-    L<<Logger::Warning<<"Reloading zones, purging data from cache"<<endl;
+    g_log<<Logger::Warning<<"Reloading zones, purging data from cache"<<endl;
 
     if (original) {
       for(const auto& i : *original) {
@@ -302,13 +302,13 @@ string reloadAuthAndForwards()
     return "ok\n";
   }
   catch(std::exception& e) {
-    L<<Logger::Error<<"Encountered error reloading zones, keeping original data: "<<e.what()<<endl;
+    g_log<<Logger::Error<<"Encountered error reloading zones, keeping original data: "<<e.what()<<endl;
   }
   catch(PDNSException& ae) {
-    L<<Logger::Error<<"Encountered error reloading zones, keeping original data: "<<ae.reason<<endl;
+    g_log<<Logger::Error<<"Encountered error reloading zones, keeping original data: "<<ae.reason<<endl;
   }
   catch(...) {
-    L<<Logger::Error<<"Encountered unknown error reloading zones, keeping original data"<<endl;
+    g_log<<Logger::Error<<"Encountered unknown error reloading zones, keeping original data"<<endl;
   }
   return "reloading failed, see log\n";
 }
@@ -336,7 +336,7 @@ std::shared_ptr<SyncRes::domainmap_t> parseAuthAndForw
       // headers.first=toCanonic("", headers.first);
       if(n==0) {
         ad.d_rdForward = false;
-        L<<Logger::Error<<"Parsing authoritative data for zone '"<<headers.first<<"' from file '"<<headers.second<<"'"<<endl;
+        g_log<<Logger::Error<<"Parsing authoritative data for zone '"<<headers.first<<"' from file '"<<headers.second<<"'"<<endl;
         ZoneParserTNG zpt(headers.second, DNSName(headers.first));
         DNSResourceRecord rr;
 	DNSRecord dr;
@@ -356,13 +356,13 @@ std::shared_ptr<SyncRes::domainmap_t> parseAuthAndForw
         }
       }
       else {
-        L<<Logger::Error<<"Redirecting queries for zone '"<<headers.first<<"' ";
+        g_log<<Logger::Error<<"Redirecting queries for zone '"<<headers.first<<"' ";
         if(n == 2) {
-          L<<"with recursion ";
+          g_log<<"with recursion ";
           ad.d_rdForward = true;
         }
         else ad.d_rdForward = false;
-        L<<"to: ";
+        g_log<<"to: ";
         
         convertServersForAD(headers.second, ad, ";");
         if(n == 2) {
@@ -376,7 +376,7 @@ std::shared_ptr<SyncRes::domainmap_t> parseAuthAndForw
   }
   
   if(!::arg()["forward-zones-file"].empty()) {
-    L<<Logger::Warning<<"Reading zone forwarding information from '"<<::arg()["forward-zones-file"]<<"'"<<endl;
+    g_log<<Logger::Warning<<"Reading zone forwarding information from '"<<::arg()["forward-zones-file"]<<"'"<<endl;
     SyncRes::AuthDomain ad;
     FILE *rfp=fopen(::arg()["forward-zones-file"].c_str(), "r");
 
@@ -421,7 +421,7 @@ std::shared_ptr<SyncRes::domainmap_t> parseAuthAndForw
       ad.d_name = DNSName(domain);
       (*newMap)[ad.d_name]=ad;
     }
-    L<<Logger::Warning<<"Done parsing " << newMap->size() - before<<" forwarding instructions from file '"<<::arg()["forward-zones-file"]<<"'"<<endl;
+    g_log<<Logger::Warning<<"Done parsing " << newMap->size() - before<<" forwarding instructions from file '"<<::arg()["forward-zones-file"]<<"'"<<endl;
   }
 
   if(::arg().mustDo("export-etc-hosts")) {
@@ -430,7 +430,7 @@ std::shared_ptr<SyncRes::domainmap_t> parseAuthAndForw
     
     ifstream ifs(fname.c_str());
     if(!ifs) {
-      L<<Logger::Warning<<"Could not open /etc/hosts for reading"<<endl;
+      g_log<<Logger::Warning<<"Could not open /etc/hosts for reading"<<endl;
     }
     else {
       string searchSuffix = ::arg()["export-etc-hosts-search-suffix"];
@@ -462,7 +462,7 @@ std::shared_ptr<SyncRes::domainmap_t> parseAuthAndForw
     }
   }
   if(::arg().mustDo("serve-rfc1918")) {
-    L<<Logger::Warning<<"Inserting rfc 1918 private space zones"<<endl;
+    g_log<<Logger::Warning<<"Inserting rfc 1918 private space zones"<<endl;
     parts.clear();
     parts.push_back("127");
     makeIPToNamesZone(newMap, parts);
--- remote_logger.cc.orig	2018-03-29 13:04:45 UTC
+++ remote_logger.cc
@@ -21,7 +21,7 @@ bool RemoteLogger::reconnect()
   }
   catch(const std::exception& e) {
 #ifdef WE_ARE_RECURSOR
-    L<<Logger::Warning<<"Error connecting to remote logger "<<d_remote.toStringWithPort()<<": "<<e.what()<<std::endl;
+    g_log<<Logger::Warning<<"Error connecting to remote logger "<<d_remote.toStringWithPort()<<": "<<e.what()<<std::endl;
 #else
     warnlog("Error connecting to remote logger %s: %s", d_remote.toStringWithPort(), e.what());
 #endif
@@ -54,7 +54,7 @@ void RemoteLogger::worker()
     }
     catch(const std::runtime_error& e) {
 #ifdef WE_ARE_RECURSOR
-      L<<Logger::Info<<"Error sending data to remote logger "<<d_remote.toStringWithPort()<<": "<< e.what()<<endl;
+      g_log<<Logger::Info<<"Error sending data to remote logger "<<d_remote.toStringWithPort()<<": "<< e.what()<<endl;
 #else
       vinfolog("Error sending data to remote logger (%s): %s", d_remote.toStringWithPort(), e.what());
 #endif
--- rpzloader.cc.orig	2018-03-29 13:04:45 UTC
+++ rpzloader.cc
@@ -110,7 +110,7 @@ void RPZRecordToPolicy(const DNSRecord& dr, std::share
     else if(!crcTarget.empty() && !crcTarget.isRoot() && crcTarget.getRawLabel(crcTarget.countLabels() - 1).compare(0, rpzPrefix.length(), rpzPrefix) == 0) {
       /* this is very likely an higher format number or a configuration error,
          let's just ignore it. */
-      L<<Logger::Info<<"Discarding unsupported RPZ entry "<<crcTarget.toString()<<" for "<<dr.d_name<<endl;
+      g_log<<Logger::Info<<"Discarding unsupported RPZ entry "<<crcTarget.toString()<<" for "<<dr.d_name<<endl;
       return;
     }
     else {
@@ -177,9 +177,9 @@ void RPZRecordToPolicy(const DNSRecord& dr, std::share
 
 shared_ptr<SOARecordContent> loadRPZFromServer(const ComboAddress& master, const DNSName& zoneName, std::shared_ptr<DNSFilterEngine::Zone> zone, boost::optional<DNSFilterEngine::Policy> defpol, uint32_t maxTTL, const TSIGTriplet& tt, size_t maxReceivedBytes, const ComboAddress& localAddress, uint16_t axfrTimeout)
 {
-  L<<Logger::Warning<<"Loading RPZ zone '"<<zoneName<<"' from "<<master.toStringWithPort()<<endl;
+  g_log<<Logger::Warning<<"Loading RPZ zone '"<<zoneName<<"' from "<<master.toStringWithPort()<<endl;
   if(!tt.name.empty())
-    L<<Logger::Warning<<"With TSIG key '"<<tt.name<<"' of algorithm '"<<tt.algo<<"'"<<endl;
+    g_log<<Logger::Warning<<"With TSIG key '"<<tt.name<<"' of algorithm '"<<tt.algo<<"'"<<endl;
 
   ComboAddress local(localAddress);
   if (local == ComboAddress())
@@ -213,11 +213,11 @@ shared_ptr<SOARecordContent> loadRPZFromServer(const C
       throw PDNSException("Total AXFR time exceeded!");
     }
     if(last != time(0)) {
-      L<<Logger::Info<<"Loaded & indexed "<<nrecords<<" policy records so far"<<endl;
+      g_log<<Logger::Info<<"Loaded & indexed "<<nrecords<<" policy records so far"<<endl;
       last=time(0);
     }
   }
-  L<<Logger::Info<<"Done: "<<nrecords<<" policy records active, SOA: "<<sr->getZoneRepresentation()<<endl;
+  g_log<<Logger::Info<<"Done: "<<nrecords<<" policy records active, SOA: "<<sr->getZoneRepresentation()<<endl;
   return sr;
 }
 
@@ -300,11 +300,11 @@ void RPZIXFRTracker(const ComboAddress& master, boost:
       setRPZZoneNewState(polName, sr->d_st.serial, zone->size(), true);
     }
     catch(const std::exception& e) {
-      theL()<<Logger::Warning<<"Unable to load RPZ zone '"<<zoneName<<"' from '"<<master<<"': '"<<e.what()<<"'. (Will try again in "<<refresh<<" seconds...)"<<endl;
+      g_log<<Logger::Warning<<"Unable to load RPZ zone '"<<zoneName<<"' from '"<<master<<"': '"<<e.what()<<"'. (Will try again in "<<refresh<<" seconds...)"<<endl;
       incRPZFailedTransfers(polName);
     }
     catch(const PDNSException& e) {
-      theL()<<Logger::Warning<<"Unable to load RPZ zone '"<<zoneName<<"' from '"<<master<<"': '"<<e.reason<<"'. (Will try again in "<<refresh<<" seconds...)"<<endl;
+      g_log<<Logger::Warning<<"Unable to load RPZ zone '"<<zoneName<<"' from '"<<master<<"': '"<<e.reason<<"'. (Will try again in "<<refresh<<" seconds...)"<<endl;
       incRPZFailedTransfers(polName);
     }
 
@@ -323,7 +323,7 @@ void RPZIXFRTracker(const ComboAddress& master, boost:
 
     sleep(refresh);
 
-    L<<Logger::Info<<"Getting IXFR deltas for "<<zoneName<<" from "<<master.toStringWithPort()<<", our serial: "<<getRR<SOARecordContent>(dr)->d_st.serial<<endl;
+    g_log<<Logger::Info<<"Getting IXFR deltas for "<<zoneName<<" from "<<master.toStringWithPort()<<", our serial: "<<getRR<SOARecordContent>(dr)->d_st.serial<<endl;
     vector<pair<vector<DNSRecord>, vector<DNSRecord> > > deltas;
 
     ComboAddress local(localAddress);
@@ -333,13 +333,13 @@ void RPZIXFRTracker(const ComboAddress& master, boost:
     try {
       deltas = getIXFRDeltas(master, zoneName, dr, tt, &local, maxReceivedBytes);
     } catch(std::runtime_error& e ){
-      L<<Logger::Warning<<e.what()<<endl;
+      g_log<<Logger::Warning<<e.what()<<endl;
       incRPZFailedTransfers(polName);
       continue;
     }
     if(deltas.empty())
       continue;
-    L<<Logger::Info<<"Processing "<<deltas.size()<<" delta"<<addS(deltas)<<" for RPZ "<<zoneName<<endl;
+    g_log<<Logger::Info<<"Processing "<<deltas.size()<<" delta"<<addS(deltas)<<" for RPZ "<<zoneName<<endl;
 
     auto luaconfsLocal = g_luaconfs.getLocal();
     const std::shared_ptr<DNSFilterEngine::Zone> oldZone = luaconfsLocal->dfe.getZone(zoneIdx);
@@ -352,7 +352,7 @@ void RPZIXFRTracker(const ComboAddress& master, boost:
       const auto& remove = delta.first;
       const auto& add = delta.second;
       if(remove.empty()) {
-        L<<Logger::Warning<<"IXFR update is a whole new zone"<<endl;
+        g_log<<Logger::Warning<<"IXFR update is a whole new zone"<<endl;
         newZone->clear();
         fullUpdate = true;
       }
@@ -365,11 +365,11 @@ void RPZIXFRTracker(const ComboAddress& master, boost:
 	    //	    cout<<"Got good removal of SOA serial "<<oldsr->d_st.serial<<endl;
 	  }
 	  else
-	    L<<Logger::Error<<"GOT WRONG SOA SERIAL REMOVAL, SHOULD TRIGGER WHOLE RELOAD"<<endl;
+	    g_log<<Logger::Error<<"GOT WRONG SOA SERIAL REMOVAL, SHOULD TRIGGER WHOLE RELOAD"<<endl;
 	}
 	else {
           totremove++;
-	  L<<(g_logRPZChanges ? Logger::Info : Logger::Debug)<<"Had removal of "<<rr.d_name<<" from RPZ zone "<<zoneName<<endl;
+	  g_log<<(g_logRPZChanges ? Logger::Info : Logger::Debug)<<"Had removal of "<<rr.d_name<<" from RPZ zone "<<zoneName<<endl;
 	  RPZRecordToPolicy(rr, newZone, false, defpol, maxTTL);
 	}
       }
@@ -379,19 +379,19 @@ void RPZIXFRTracker(const ComboAddress& master, boost:
           continue;
 	if(rr.d_type == QType::SOA) {
 	  auto newsr = getRR<SOARecordContent>(rr);
-	  //	  L<<Logger::Info<<"New SOA serial for "<<zoneName<<": "<<newsr->d_st.serial<<endl;
+	  //	  g_log<<Logger::Info<<"New SOA serial for "<<zoneName<<": "<<newsr->d_st.serial<<endl;
 	  if (newsr) {
 	    sr = newsr;
 	  }
 	}
 	else {
           totadd++;
-	  L<<(g_logRPZChanges ? Logger::Info : Logger::Debug)<<"Had addition of "<<rr.d_name<<" to RPZ zone "<<zoneName<<endl;
+	  g_log<<(g_logRPZChanges ? Logger::Info : Logger::Debug)<<"Had addition of "<<rr.d_name<<" to RPZ zone "<<zoneName<<endl;
 	  RPZRecordToPolicy(rr, newZone, true, defpol, maxTTL);
 	}
       }
     }
-    L<<Logger::Info<<"Had "<<totremove<<" RPZ removal"<<addS(totremove)<<", "<<totadd<<" addition"<<addS(totadd)<<" for "<<zoneName<<" New serial: "<<sr->d_st.serial<<endl;
+    g_log<<Logger::Info<<"Had "<<totremove<<" RPZ removal"<<addS(totremove)<<", "<<totadd<<" addition"<<addS(totadd)<<" for "<<zoneName<<" New serial: "<<sr->d_st.serial<<endl;
     newZone->setSerial(sr->d_st.serial);
     setRPZZoneNewState(polName, sr->d_st.serial, newZone->size(), fullUpdate);
 
--- secpoll-recursor.cc.orig	2018-03-29 13:04:45 UTC
+++ secpoll-recursor.cc
@@ -55,7 +55,7 @@ void doSecPoll(time_t* last_secpoll)
   }
 
   if(state == Bogus) {
-    L<<Logger::Error<<"Could not retrieve security status update for '" +pkgv+ "' on '"<<query<<"', DNSSEC validation result was Bogus!"<<endl;
+    g_log<<Logger::Error<<"Could not retrieve security status update for '" +pkgv+ "' on '"<<query<<"', DNSSEC validation result was Bogus!"<<endl;
     if(g_security_status == 1) // If we were OK, go to unknown
       g_security_status = 0;
     return;
@@ -79,18 +79,18 @@ void doSecPoll(time_t* last_secpoll)
   }
   else {
     if(pkgv.find("0.0.") != 0)
-      L<<Logger::Warning<<"Could not retrieve security status update for '" +pkgv+ "' on '"<<query<<"', RCODE = "<< RCode::to_s(res)<<endl;
+      g_log<<Logger::Warning<<"Could not retrieve security status update for '" +pkgv+ "' on '"<<query<<"', RCODE = "<< RCode::to_s(res)<<endl;
     else
-      L<<Logger::Warning<<"Ignoring response for security status update, this is a non-release version."<<endl;
+      g_log<<Logger::Warning<<"Ignoring response for security status update, this is a non-release version."<<endl;
 
     if(g_security_status == 1) // it was ok, now it is unknown
       g_security_status = 0;
   }
 
   if(g_security_status == 2) {
-    L<<Logger::Error<<"PowerDNS Security Update Recommended: "<<g_security_message<<endl;
+    g_log<<Logger::Error<<"PowerDNS Security Update Recommended: "<<g_security_message<<endl;
   }
   else if(g_security_status == 3) {
-    L<<Logger::Error<<"PowerDNS Security Update Mandatory: "<<g_security_message<<endl;
+    g_log<<Logger::Error<<"PowerDNS Security Update Mandatory: "<<g_security_message<<endl;
   }
 }
--- syncres.cc.orig	2018-03-29 13:04:45 UTC
+++ syncres.cc
@@ -75,7 +75,7 @@ bool SyncRes::s_nopacketcache;
 bool SyncRes::s_rootNXTrust;
 bool SyncRes::s_noEDNS;
 
-#define LOG(x) if(d_lm == Log) { L <<Logger::Warning << x; } else if(d_lm == Store) { d_trace << x; }
+#define LOG(x) if(d_lm == Log) { g_log <<Logger::Warning << x; } else if(d_lm == Store) { d_trace << x; }
 
 static void accountAuthLatency(int usec, int family)
 {
@@ -2855,23 +2855,23 @@ int SyncRes::getRootNS(struct timeval now, asyncresolv
     return res;
   }
   catch(const PDNSException& e) {
-    L<<Logger::Error<<"Failed to update . records, got an exception: "<<e.reason<<endl;
+    g_log<<Logger::Error<<"Failed to update . records, got an exception: "<<e.reason<<endl;
   }
   catch(const ImmediateServFailException& e) {
-    L<<Logger::Error<<"Failed to update . records, got an exception: "<<e.reason<<endl;
+    g_log<<Logger::Error<<"Failed to update . records, got an exception: "<<e.reason<<endl;
   }
   catch(const std::exception& e) {
-    L<<Logger::Error<<"Failed to update . records, got an exception: "<<e.what()<<endl;
+    g_log<<Logger::Error<<"Failed to update . records, got an exception: "<<e.what()<<endl;
   }
   catch(...) {
-    L<<Logger::Error<<"Failed to update . records, got an exception"<<endl;
+    g_log<<Logger::Error<<"Failed to update . records, got an exception"<<endl;
   }
 
   if(!res) {
-    L<<Logger::Notice<<"Refreshed . records"<<endl;
+    g_log<<Logger::Notice<<"Refreshed . records"<<endl;
   }
   else
-    L<<Logger::Error<<"Failed to update . records, RCODE="<<res<<endl;
+    g_log<<Logger::Error<<"Failed to update . records, RCODE="<<res<<endl;
 
   return res;
 }
--- test-syncres_cc.cc.orig	2018-03-29 13:04:45 UTC
+++ test-syncres_cc.cc
@@ -101,16 +101,16 @@ LuaConfigItems::LuaConfigItems()
 
 static void init(bool debug=false)
 {
-  L.setName("test");
-  L.disableSyslog(true);
+  g_log.setName("test");
+  g_log.disableSyslog(true);
 
   if (debug) {
-    L.setLoglevel((Logger::Urgency)(6)); // info and up
-    L.toConsole(Logger::Info);
+    g_log.setLoglevel((Logger::Urgency)(6)); // info and up
+    g_log.toConsole(Logger::Info);
   }
   else {
-    L.setLoglevel(Logger::None);
-    L.toConsole(Logger::Error);
+    g_log.setLoglevel(Logger::None);
+    g_log.toConsole(Logger::Error);
   }
 
   seedRandom("/dev/urandom");
--- unix_utility.cc.orig	2018-03-29 13:04:45 UTC
+++ unix_utility.cc
@@ -84,22 +84,22 @@ void Utility::setBindAny(int af, sock_t sock)
   (void) one; // avoids 'unused var' warning on systems that have none of the defines checked below
 #ifdef IP_FREEBIND
   if (setsockopt(sock, IPPROTO_IP, IP_FREEBIND, &one, sizeof(one)) < 0)
-      theL()<<Logger::Warning<<"Warning: IP_FREEBIND setsockopt failed: "<<strerror(errno)<<endl;
+      g_log<<Logger::Warning<<"Warning: IP_FREEBIND setsockopt failed: "<<strerror(errno)<<endl;
 #endif
 
 #ifdef IP_BINDANY
   if (af == AF_INET)
     if (setsockopt(sock, IPPROTO_IP, IP_BINDANY, &one, sizeof(one)) < 0)
-      theL()<<Logger::Warning<<"Warning: IP_BINDANY setsockopt failed: "<<strerror(errno)<<endl;
+      g_log<<Logger::Warning<<"Warning: IP_BINDANY setsockopt failed: "<<strerror(errno)<<endl;
 #endif
 #ifdef IPV6_BINDANY
   if (af == AF_INET6)
     if (setsockopt(sock, IPPROTO_IPV6, IPV6_BINDANY, &one, sizeof(one)) < 0)
-      theL()<<Logger::Warning<<"Warning: IPV6_BINDANY setsockopt failed: "<<strerror(errno)<<endl;
+      g_log<<Logger::Warning<<"Warning: IPV6_BINDANY setsockopt failed: "<<strerror(errno)<<endl;
 #endif
 #ifdef SO_BINDANY
   if (setsockopt(sock, SOL_SOCKET, SO_BINDANY, &one, sizeof(one)) < 0)
-      theL()<<Logger::Warning<<"Warning: SO_BINDANY setsockopt failed: "<<strerror(errno)<<endl;
+      g_log<<Logger::Warning<<"Warning: SO_BINDANY setsockopt failed: "<<strerror(errno)<<endl;
 #endif
 }
 
@@ -128,22 +128,22 @@ void Utility::dropGroupPrivs( int uid, int gid )
 {
   if(gid) {
     if(setgid(gid)<0) {
-      theL()<<Logger::Critical<<"Unable to set effective group id to "<<gid<<": "<<stringerror()<<endl;
+      g_log<<Logger::Critical<<"Unable to set effective group id to "<<gid<<": "<<stringerror()<<endl;
       exit(1);
     }
     else
-      theL()<<Logger::Info<<"Set effective group id to "<<gid<<endl;
+      g_log<<Logger::Info<<"Set effective group id to "<<gid<<endl;
 
     struct passwd *pw=getpwuid(uid);
     if(!pw) {
-      theL()<<Logger::Warning<<"Unable to determine user name for uid "<<uid<<endl;
+      g_log<<Logger::Warning<<"Unable to determine user name for uid "<<uid<<endl;
       if (setgroups(0, NULL)<0) {
-        theL()<<Logger::Critical<<"Unable to drop supplementary gids: "<<stringerror()<<endl;
+        g_log<<Logger::Critical<<"Unable to drop supplementary gids: "<<stringerror()<<endl;
         exit(1);
       }
     } else {
       if (initgroups(pw->pw_name, gid)<0) {
-        theL()<<Logger::Critical<<"Unable to set supplementary groups: "<<stringerror()<<endl;
+        g_log<<Logger::Critical<<"Unable to set supplementary groups: "<<stringerror()<<endl;
         exit(1);
       }
     }
@@ -156,11 +156,11 @@ void Utility::dropUserPrivs( int uid )
 {
   if(uid) {
     if(setuid(uid)<0) {
-      theL()<<Logger::Critical<<"Unable to set effective user id to "<<uid<<":  "<<stringerror()<<endl;
+      g_log<<Logger::Critical<<"Unable to set effective user id to "<<uid<<":  "<<stringerror()<<endl;
       exit(1);
     }
     else
-      theL()<<Logger::Info<<"Set effective user id to "<<uid<<endl;
+      g_log<<Logger::Info<<"Set effective user id to "<<uid<<endl;
   }
 }
 
@@ -188,7 +188,7 @@ int Utility::makeGidNumeric(const string &group)
     errno=0;
     struct group *gr=getgrnam(group.c_str());
     if(!gr) {
-      theL()<<Logger::Critical<<"Unable to look up gid of group '"<<group<<"': "<< (errno ? strerror(errno) : "not found") <<endl;
+      g_log<<Logger::Critical<<"Unable to look up gid of group '"<<group<<"': "<< (errno ? strerror(errno) : "not found") <<endl;
       exit(1);
     }
     newgid=gr->gr_gid;
@@ -204,7 +204,7 @@ int Utility::makeUidNumeric(const string &username)
   if(!(newuid=atoi(username.c_str()))) {
     struct passwd *pw=getpwnam(username.c_str());
     if(!pw) {
-      theL()<<Logger::Critical<<"Unable to look up uid of user '"<<username<<"': "<< (errno ? strerror(errno) : "not found") <<endl;
+      g_log<<Logger::Critical<<"Unable to look up uid of user '"<<username<<"': "<< (errno ? strerror(errno) : "not found") <<endl;
       exit(1);
     }
     newuid=pw->pw_uid;
--- validate-recursor.cc.orig	2018-03-29 13:04:45 UTC
+++ validate-recursor.cc
@@ -13,7 +13,7 @@ bool checkDNSSECDisabled() {
 bool warnIfDNSSECDisabled(const string& msg) {
   if(g_dnssecmode == DNSSECMode::Off) {
     if (!msg.empty())
-      L<<Logger::Warning<<msg<<endl;
+      g_log<<Logger::Warning<<msg<<endl;
     return true;
   }
   return false;
--- validate.cc.orig	2018-03-29 13:04:45 UTC
+++ validate.cc
@@ -8,7 +8,7 @@
 bool g_dnssecLOG{false};
 uint16_t g_maxNSEC3Iterations{0};
 
-#define LOG(x) if(g_dnssecLOG) { L <<Logger::Warning << x; }
+#define LOG(x) if(g_dnssecLOG) { g_log <<Logger::Warning << x; }
 void dotEdge(DNSName zone, string type1, DNSName name1, string tag1, string type2, DNSName name2, string tag2, string color="");
 void dotNode(string type, DNSName name, string tag, string content);
 string dotName(string type, DNSName name, string tag);
--- version.cc.orig	2018-03-29 13:04:45 UTC
+++ version.cc
@@ -71,22 +71,22 @@ string productTypeApiType() {
 
 void showProductVersion()
 {
-  theL()<<Logger::Warning<<productName()<<" "<< VERSION << " (C) 2001-2017 "
+  g_log<<Logger::Warning<<productName()<<" "<< VERSION << " (C) 2001-2017 "
     "PowerDNS.COM BV" << endl;
-  theL()<<Logger::Warning<<"Using "<<(sizeof(unsigned long)*8)<<"-bits mode. "
+  g_log<<Logger::Warning<<"Using "<<(sizeof(unsigned long)*8)<<"-bits mode. "
     "Built using " << compilerVersion()
 #ifndef REPRODUCIBLE
     <<" on " __DATE__ " " __TIME__ " by " BUILD_HOST
 #endif
     <<"."<< endl;
-  theL()<<Logger::Warning<<"PowerDNS comes with ABSOLUTELY NO WARRANTY. "
+  g_log<<Logger::Warning<<"PowerDNS comes with ABSOLUTELY NO WARRANTY. "
     "This is free software, and you are welcome to redistribute it "
     "according to the terms of the GPL version 2." << endl;
 }
 
 void showBuildConfiguration()
 {
-  theL()<<Logger::Warning<<"Features: "<<
+  g_log<<Logger::Warning<<"Features: "<<
 #ifdef HAVE_BOTAN
     "botan" << BOTAN_VERSION_MAJOR << "." << BOTAN_VERSION_MINOR  << " " <<
 #endif
@@ -115,12 +115,12 @@ void showBuildConfiguration()
     endl;
 #ifdef PDNS_MODULES
   // Auth only
-  theL()<<Logger::Warning<<"Built-in modules: "<<PDNS_MODULES<<endl;
+  g_log<<Logger::Warning<<"Built-in modules: "<<PDNS_MODULES<<endl;
 #endif
 #ifdef PDNS_CONFIG_ARGS
 #define double_escape(s) #s
 #define escape_quotes(s) double_escape(s)
-  theL()<<Logger::Warning<<"Configured with: "<<escape_quotes(PDNS_CONFIG_ARGS)<<endl;
+  g_log<<Logger::Warning<<"Configured with: "<<escape_quotes(PDNS_CONFIG_ARGS)<<endl;
 #undef escape_quotes
 #undef double_escape
 #endif
--- webserver.cc.orig	2018-03-29 13:04:45 UTC
+++ webserver.cc
@@ -39,12 +39,12 @@ json11::Json HttpRequest::json()
 {
   string err;
   if(this->body.empty()) {
-    L<<Logger::Debug<<"HTTP: JSON document expected in request body, but body was empty" << endl;
+    g_log<<Logger::Debug<<"HTTP: JSON document expected in request body, but body was empty" << endl;
     throw HttpBadRequestException();
   }
   json11::Json doc = json11::Json::parse(this->body, err);
   if (doc.is_null()) {
-    L<<Logger::Debug<<"HTTP: parsing of JSON document failed:" << err << endl;
+    g_log<<Logger::Debug<<"HTTP: parsing of JSON document failed:" << err << endl;
     throw HttpBadRequestException();
   }
   return doc;
@@ -132,13 +132,13 @@ static void apiWrapper(WebServer::HandlerFunction hand
   resp->headers["access-control-allow-origin"] = "*";
 
   if (api_key.empty()) {
-    L<<Logger::Error<<"HTTP API Request \"" << req->url.path << "\": Authentication failed, API Key missing in config" << endl;
+    g_log<<Logger::Error<<"HTTP API Request \"" << req->url.path << "\": Authentication failed, API Key missing in config" << endl;
     throw HttpUnauthorizedException("X-API-Key");
   }
   bool auth_ok = req->compareHeader("x-api-key", api_key) || req->getvars["api-key"]==api_key;
   
   if (!auth_ok) {
-    L<<Logger::Error<<"HTTP Request \"" << req->url.path << "\": Authentication by API Key failed" << endl;
+    g_log<<Logger::Error<<"HTTP Request \"" << req->url.path << "\": Authentication by API Key failed" << endl;
     throw HttpUnauthorizedException("X-API-Key");
   }
 
@@ -181,7 +181,7 @@ static void webWrapper(WebServer::HandlerFunction hand
   if (!web_password.empty()) {
     bool auth_ok = req->compareAuthorization(web_password);
     if (!auth_ok) {
-      L<<Logger::Debug<<"HTTP Request \"" << req->url.path << "\": Web Authentication failed" << endl;
+      g_log<<Logger::Debug<<"HTTP Request \"" << req->url.path << "\": Web Authentication failed" << endl;
       throw HttpUnauthorizedException("Basic");
     }
   }
@@ -206,11 +206,11 @@ void WebServer::handleRequest(HttpRequest& req, HttpRe
 
   try {
     if (!req.complete) {
-      L<<Logger::Debug<<"HTTP: Incomplete request" << endl;
+      g_log<<Logger::Debug<<"HTTP: Incomplete request" << endl;
       throw HttpBadRequestException();
     }
 
-    L<<Logger::Debug<<"HTTP: Handling request \"" << req.url.path << "\"" << endl;
+    g_log<<Logger::Debug<<"HTTP: Handling request \"" << req.url.path << "\"" << endl;
 
     YaHTTP::strstr_map_t::iterator header;
 
@@ -225,33 +225,33 @@ void WebServer::handleRequest(HttpRequest& req, HttpRe
 
     YaHTTP::THandlerFunction handler;
     if (!YaHTTP::Router::Route(&req, handler)) {
-      L<<Logger::Debug<<"HTTP: No route found for \"" << req.url.path << "\"" << endl;
+      g_log<<Logger::Debug<<"HTTP: No route found for \"" << req.url.path << "\"" << endl;
       throw HttpNotFoundException();
     }
 
     try {
       handler(&req, &resp);
-      L<<Logger::Debug<<"HTTP: Result for \"" << req.url.path << "\": " << resp.status << ", body length: " << resp.body.size() << endl;
+      g_log<<Logger::Debug<<"HTTP: Result for \"" << req.url.path << "\": " << resp.status << ", body length: " << resp.body.size() << endl;
     }
     catch(HttpException&) {
       throw;
     }
     catch(PDNSException &e) {
-      L<<Logger::Error<<"HTTP ISE for \""<< req.url.path << "\": Exception: " << e.reason << endl;
+      g_log<<Logger::Error<<"HTTP ISE for \""<< req.url.path << "\": Exception: " << e.reason << endl;
       throw HttpInternalServerErrorException();
     }
     catch(std::exception &e) {
-      L<<Logger::Error<<"HTTP ISE for \""<< req.url.path << "\": STL Exception: " << e.what() << endl;
+      g_log<<Logger::Error<<"HTTP ISE for \""<< req.url.path << "\": STL Exception: " << e.what() << endl;
       throw HttpInternalServerErrorException();
     }
     catch(...) {
-      L<<Logger::Error<<"HTTP ISE for \""<< req.url.path << "\": Unknown Exception" << endl;
+      g_log<<Logger::Error<<"HTTP ISE for \""<< req.url.path << "\": Unknown Exception" << endl;
       throw HttpInternalServerErrorException();
     }
   }
   catch(HttpException &e) {
     resp = e.response();
-    L<<Logger::Debug<<"HTTP: Error result for \"" << req.url.path << "\": " << resp.status << endl;
+    g_log<<Logger::Debug<<"HTTP: Error result for \"" << req.url.path << "\": " << resp.status << endl;
     string what = YaHTTP::Utility::status2text(resp.status);
     if(req.accept_html) {
       resp.headers["Content-Type"] = "text/html; charset=utf-8";
@@ -311,14 +311,14 @@ try {
   client->writenWithTimeout(reply.c_str(), reply.size(), timeout);
 }
 catch(PDNSException &e) {
-  L<<Logger::Error<<"HTTP Exception: "<<e.reason<<endl;
+  g_log<<Logger::Error<<"HTTP Exception: "<<e.reason<<endl;
 }
 catch(std::exception &e) {
   if(strstr(e.what(), "timeout")==0)
-    L<<Logger::Error<<"HTTP STL Exception: "<<e.what()<<endl;
+    g_log<<Logger::Error<<"HTTP STL Exception: "<<e.what()<<endl;
 }
 catch(...) {
-  L<<Logger::Error<<"HTTP: Unknown exception"<<endl;
+  g_log<<Logger::Error<<"HTTP: Unknown exception"<<endl;
 }
 
 WebServer::WebServer(const string &listenaddress, int port) : d_server(nullptr)
@@ -331,10 +331,10 @@ void WebServer::bind()
 {
   try {
     d_server = createServer();
-    L<<Logger::Warning<<"Listening for HTTP requests on "<<d_server->d_local.toStringWithPort()<<endl;
+    g_log<<Logger::Warning<<"Listening for HTTP requests on "<<d_server->d_local.toStringWithPort()<<endl;
   }
   catch(NetworkError &e) {
-    L<<Logger::Error<<"Listening on HTTP socket failed: "<<e.what()<<endl;
+    g_log<<Logger::Error<<"Listening on HTTP socket failed: "<<e.what()<<endl;
     d_server = nullptr;
   }
 }
@@ -359,28 +359,28 @@ void WebServer::go()
         } else {
           ComboAddress remote;
           if (client->getRemote(remote))
-            L<<Logger::Error<<"Webserver closing socket: remote ("<< remote.toString() <<") does not match 'webserver-allow-from'"<<endl;
+            g_log<<Logger::Error<<"Webserver closing socket: remote ("<< remote.toString() <<") does not match 'webserver-allow-from'"<<endl;
         }
       }
       catch(PDNSException &e) {
-        L<<Logger::Error<<"PDNSException while accepting a connection in main webserver thread: "<<e.reason<<endl;
+        g_log<<Logger::Error<<"PDNSException while accepting a connection in main webserver thread: "<<e.reason<<endl;
       }
       catch(std::exception &e) {
-        L<<Logger::Error<<"STL Exception while accepting a connection in main webserver thread: "<<e.what()<<endl;
+        g_log<<Logger::Error<<"STL Exception while accepting a connection in main webserver thread: "<<e.what()<<endl;
       }
       catch(...) {
-        L<<Logger::Error<<"Unknown exception while accepting a connection in main webserver thread"<<endl;
+        g_log<<Logger::Error<<"Unknown exception while accepting a connection in main webserver thread"<<endl;
       }
     }
   }
   catch(PDNSException &e) {
-    L<<Logger::Error<<"PDNSException in main webserver thread: "<<e.reason<<endl;
+    g_log<<Logger::Error<<"PDNSException in main webserver thread: "<<e.reason<<endl;
   }
   catch(std::exception &e) {
-    L<<Logger::Error<<"STL Exception in main webserver thread: "<<e.what()<<endl;
+    g_log<<Logger::Error<<"STL Exception in main webserver thread: "<<e.what()<<endl;
   }
   catch(...) {
-    L<<Logger::Error<<"Unknown exception in main webserver thread"<<endl;
+    g_log<<Logger::Error<<"Unknown exception in main webserver thread"<<endl;
   }
   _exit(1);
 }
--- ws-recursor.cc.orig	2018-03-29 13:04:45 UTC
+++ ws-recursor.cc
@@ -584,11 +584,11 @@ void AsyncServerNewConnectionMT(void *p) {
     }
   } catch (NetworkError &e) {
     // we're running in a shared process/thread, so can't just terminate/abort.
-    L<<Logger::Warning<<"Network error in web thread: "<<e.what()<<endl;
+    g_log<<Logger::Warning<<"Network error in web thread: "<<e.what()<<endl;
     return;
   }
   catch (...) {
-    L<<Logger::Warning<<"Unknown error in web thread"<<endl;
+    g_log<<Logger::Warning<<"Unknown error in web thread"<<endl;
 
     return;
   }
@@ -638,18 +638,18 @@ try {
 
   // now send the reply
   if (asendtcp(data, client.get()) == -1 || data.empty()) {
-    L<<Logger::Error<<"Failed sending reply to HTTP client"<<endl;
+    g_log<<Logger::Error<<"Failed sending reply to HTTP client"<<endl;
   }
 }
 catch(PDNSException &e) {
-  L<<Logger::Error<<"HTTP Exception: "<<e.reason<<endl;
+  g_log<<Logger::Error<<"HTTP Exception: "<<e.reason<<endl;
 }
 catch(std::exception &e) {
   if(strstr(e.what(), "timeout")==0)
-    L<<Logger::Error<<"HTTP STL Exception: "<<e.what()<<endl;
+    g_log<<Logger::Error<<"HTTP STL Exception: "<<e.what()<<endl;
 }
 catch(...) {
-  L<<Logger::Error<<"HTTP: Unknown exception"<<endl;
+  g_log<<Logger::Error<<"HTTP: Unknown exception"<<endl;
 }
 
 void AsyncWebServer::go() {
